
int main()
{
	int intarr[10],*p;
	p = intarr;
	for (int k = 0; k < 10; k++)
	{
		cin >> *p;
		p++;
	}
	p--;
	cout << endl;
	for (int k = 10; k >0; k--)
	{
		cout << *p << endl;
		p--;
	}
	p++;
	cout << endl;
	for (int k = 9; k > -1; k--)
	{
		cout <<intarr[k] << endl;
	}
}


//find the max num from inputs
int main()
{
	int *intarr[3],*intarr1[3], *p, maxnum;
    //give new space
	for (int i = 0; i < 3; i++)
	{
		intarr[i] = new int[4];
		intarr1[i] = intarr[i];
	}
	//input data
	cout << "please input the numbers" << endl;
	for (int i = 0; i < 3; i++)
	{
		cin >> *intarr[i];
		intarr[i]++;
		cin >> *intarr[i];
		intarr[i]++;
		cin >> *intarr[i];
		intarr[i]++; 
		cin >> *intarr[i];
	}
	//give the original address
	for (int i = 0; i < 3; i++)
		intarr[i] =	intarr1[i] ;
	//find the max num
	maxnum = *intarr[0];
	for (int i = 0; i < 3; i++)
	{
		if (*intarr[i]>maxnum)
			maxnum = *intarr[i];
		intarr[i]++;
		if (*intarr[i]>maxnum)
			maxnum = *intarr[i];
		intarr[i]++;
		if (*intarr[i]>maxnum)
			maxnum = *intarr[i];
		intarr[i]++;
		if (*intarr[i]>maxnum)
			maxnum = *intarr[i];
	}
	//output the max num
	cout << maxnum << endl;
	//give the original address
	for (int i = 0; i < 3; i++)
		intarr[i] =	intarr1[i] ;
	//delete the new space
	for (int i = 0; i < 3; i++)
	{
		intarr[i] = new int[4];
		intarr1[i] = intarr[i];
	}

	
}

//output your numbers in inverse order
int main()
{
	float n[10], m[10];
	int k = 0;
	cout << "please input ten numbers"<<endl;
	for (int i = 0; i < 10; i++)
	{
		cin >> n[i];
	}
	for (int i = 9; i>-1; i--)
	{
		m[i] = n[k];
		k++;
	}
	cout << endl;
	for (int i = 0; i < 10; i++)
	{

		n[i] = m[i];
		cout << n[i] << endl;
	}
}


//output your chars in inverse order with a recusion
void out(int, int, char *str);
int main()
{
	char *str = "abcdef";
	int i = 0,len=6;
	out(i, len, str);
	return 0;
}
void out(int i, int len, char *str)
{
	if (i < (len - 1))
		out(i + 1, len, str);
	cout << str[i]<<endl;
}



//find the numbers of capital letters in string
int numbers(char str[]);
int main()
{
	char str[] = "C++ Programming Language";
	cout << numbers(str) << endl;
	return 0;
}

int numbers(char str[])
{
	int i = 0,k=0;
	cout << str[0]<<endl;
	while (str[i] != '\0')
	{
		switch(str[i])
		{
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
				k++; break;
			default:break;
		}
		i++;
	}
	return k;
}



//using a recusion function
long sum(int);
int main()
{
	int n;
	cout << "please input the length" << endl;
	cin >> n;
	cout << sum(n) << endl;
	return 0;
}

long sum(int n)
{
	long f;
	if (n == 1)
		f = 1;
	else
		f = n + sum(n - 1);
	return f;

}



//show the useage of the standard input and output
int main()
{
	int n=3,m=123456;
	float j=3.6,i=4123.0;
	cout << showbase << showpos<<n<<endl;
	cout << noshowbase << noshowpos << n << endl;
	cout << showpoint << j << '\t' << '\t' <<i<< endl;
	cout << noshowpoint << j << '\t' << '\t' <<i<< endl;
	cout << scientific << j << '\t' << '\t' << i<< endl;
	cout << j << '\t' << '\t' << i << endl;
	cout << oct << j << '\t' << '\t' << m<< endl;
	cout << hex << j << '\t' << '\t' << m << endl;
	cout << hex <<uppercase<<m << '\t' << '\t' << m << endl;
	cout << hex << nouppercase << m << '\t' << '\t' <<m << endl;
	
	cout << j << '\t' << '\t' << n << endl;

	return 0;//copy content of a txt document to the other document
int main()
{
	char ch;
	ifstream in("test.txt");
	ofstream out("file_to.txt");
	if (!in)
	{
		cout << "cannot open file!";
			return 0;
	}
	if (!out)
	{
		cout << "cannot open file!";
		return 0;
	}
	while (in.get(ch))
		out.put(ch);
	in.close();
	out.close();
	return 0;
}

}

//show content of a txt document
int main()
{
	char ch;
	ifstream in("test.txt");
	if (!in)
	{
		cout << "cannot open file!";
			return 0;
	}
	while (in.get(ch))
		cout << ch;
	in.close();
	return 0;
}



//问题解决，试图重载流提取运算符>>时，在声明时写对了，在定义时把>>写成了<<，错误提示中有指出：无法解析的外部符号
//                                                                        "class std::basic_istream<char,struct std::char_traits<char> > & __cdecl operator
//                                                                        >>
//                                                                        (class std::basic_istream<char,struct std::char_traits<char> > &,class student &)"
//也无法用非静态成员函来对静态数据成员赋值，否则会提示：无法解析的外部符号
//                                                                         "public: static
//                                                                         class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
//                                                                         student::course"

#include <iostream>
#include<string>
using namespace std;
class student
{
public:
	 string name;
	 string course;
	 int score;
	friend ostream& operator<<(ostream&, student&);
	friend istream& operator>>(istream&, student&);
};

ostream & operator <<(ostream &output, student & mystudent)
{
	output << mystudent.name << '\t' << mystudent.course << '\t' << mystudent.score << endl;
	return output;
}
istream & operator<<(istream &input, student & mystudent)
{
	input >> mystudent.name;
	input >> mystudent.course;
	input >> mystudent.score;
	return input;
}
int main()
{
	student mystudent;
	cin >> mystudent;
	cout << mystudent;
	return 0;
}






//output the 9*9 multiplication table
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
	int i=1, j=1;
	for (i = 1; i < 10; i++)
	{
		for (j = 1; j < (i + 1); j++)
		{
			cout << setw(3) << j << "*" << i << "=" << i*j;
			if (i*j < 10)
				cout << '\0';
		}
		cout << endl;
	}
	return 0;
}



//两个问题，一个是不正常显示，一个是输入字符无重复时程序崩溃。
//定义一个类，其中能包含一个字符串，其长度，以及可以指定删除其中的单个字符
// ch13_10.cpp : Defines the entry point for the console application.
//


#include <iostream>
#include <string>
using namespace std;

class mystring
{
	int length;				//串长
	char * contents;			//串的内容
public:
	mystring(char *s);			//构造函数，带参数
	~mystring();
    void show();
	void deletec();
};

mystring::mystring(char *s)
{
	length=strlen(s);			//计算串长
	contents=new char [length+1];	//申请内存
	strcpy_s(contents,length+1,s);			//串赋值
}
mystring::~mystring()
{
	delete[] contents;			//释放串的空间
	length=0;					//初始化串长度
}
void mystring::show()
{
	cout<<"mystring is \""<<contents<<"ttt\". The length is "<<length<<"."<<endl;
}
void mystring::deletec()
{
	char c,*s,*ss,*ms,*mc;
	int len=0;
	s = new char[length + 1];
	ss = new char[length + 1];
	ms = s, mc = contents;
	cout << "please input the char you want to delete" << endl;
	cin >> c;

	while (*contents != '\0')
	{
		if (*contents != c)
		{
			*s = *contents;
			s++,len++;
		}
		contents++;
	}
	s++, *s = '\0';
	s = ms, contents = mc;

	/*for (; length > 0; length--)
	{
		*contents='\0';
		contents++;
	}
	s = ms, contents = mc;
	*/

	strcpy_s(contents, len+1+1, s);
	
	/*strcpy_s(ss, len + 1, s);
	cout << endl;
	cout << ss << endl;
	*/
	
	length = len;
	delete[] s;
	delete[] ss;
}
void main()
{
	mystring s1("the first mystring");
	s1.show();
	s1.deletec();
	s1.show();
	mystring s2("the second mystring");
	s2.show();
	s2.deletec();
	s2.show();
}


//class for time
#include <iostream>
#include <string>
using namespace std;

class time
{
private:
	int day;
	int month;
	int year;
public:
	time();
	time(int, int, int);
	void show();

};
time::time()
{
	day = 0;
	month = 0;
	year = 0;
}
time::time(int newday, int newmonth, int newyear)
{
	day = newday;
	month = newmonth;
	year = newyear;
}
void time::show()
{
	cout << year << "year" << month << "month" << day << "day" << endl;
}
int main()
{
	time t1;
	t1.show();
	time t2(2015, 8, 02);
	t2.show();
	return 0;
	
}

//问题解决，用cout<<a形式输出字符串，必须使a的最后一个元素为空字符，否则会输出大量乱码
#include<iostream>
#include<string>
#include"resource.h"
using namespace std;
using namespace spacea;
//========================================
int main()
{
	char *a, *b, *ma, *mb;
	a = new char[100], b = new char[100];
	ma = a, mb = b;
	stringcp(a, "hello world");
	stringcp(b, "i am well");
	cout << "a:   " << a << endl;
	cout << "b:   " << b << endl;
	stringex(a, b);
	cout << "a:   " << a << endl;
	cout << "b:   " << b << endl;
	a = ma, b = mb;
	delete[]b;
	delete[]a;
	return 0;
}
#include <string>
using namespace std;
namespace spacea
{
	void stringex(char* a, char* b)
	{
		int lengtha,lengthb;
		char c,*d;
		lengtha = strlen(a);
		lengthb = strlen(b);
		if (lengtha > lengthb)
			d=a,a=b,b=d;
		while (*b != '\0')
		{
			c = *a;
			*a = *b;
			if (c != '\0')
				*b = c;
			else
				*b = '\0';
			a++, b++;
		}
		*a = '\0';

	}
	void stringcp(char *a, char *b)
	{
		while (*b != '\0')
		{
			*a = *b;
			a++, b++;
		}
		a++, *a = '\0';
	}
}


12.1
//point.h
#include <iostream>
using namespace std;
class point
{
public:
	point(float x = 0, float y = 0);
	void setpoint(float, float);
	float getx() const{ return x; }
	float gety() const{ return y; }
	friend ostream& operator<<(ostream &, const point &);
protected:
	float x, y;

};

//circle.h
#include <iostream>
using namespace std;

class circle :public point
{
	public:
		circle(float a = 0, float b = 0, float r = 0);
		void setradius(float r = 0);
		float getradius()const;
		float area()const;
		friend ostream& operator<<(ostream&, const circle&);
	protected:
		float radius;
};
//cylinder.h
#include<iostream>
using namespace std;
class cylinder :public circle
{
public:
	cylinder(float x = 0, float y = 0, float r = 0, float h = 0);
	void setheight(float);
	float getheight()const;
	float area()const;
	float volume()const;
	friend ostream& operator<<(ostream&, const cylinder&);
protected:
	float height;
};
//point.cpp
#include "point.h"
#include"iostream"
using namespace std;
point::point(float a, float b)
{
	x = a, y = b;
}
void point::setpoint(float a, float b)
{
	x=a, y=b;
}
ostream& operator<<(ostream& output, const point& p)
{
	output << "[" << p.x << "," << p.y << "]" << endl;
	return output;
}
//circle.cpp
#include"point.h"
#include"circle.h"
#include<iostream>
using namespace std;

circle::circle(float a, float b, float r) :point(a, b), radius(r){}
void circle::setradius(float r)
{
	radius = r;
}
float circle::getradius()const
{
	return radius;
}
float circle::area()const
{
	return 3.1415*radius*radius;
}
ostream& operator<<(ostream&output, const circle& c)
{
	output << "center=[" << c.x << "," << c.y << "],r=" << c.radius << ",area=" << c.area() << endl;
	return output;
}
//cylinder.cpp
#include"point.h"
#include"circle.h"
#include"cylinder.h"
#include<iostream>
using namespace std;
cylinder::cylinder(float a, float b, float r, float h) :circle(a, b, r), height(h){}
void cylinder::setheight(float h) { height = h; }
float cylinder::getheight()const
{
	return height;
}
float cylinder::area()const
{
	return 2 * circle::area() + 2 * 3.14159*radius*height;
}
float cylinder::volume()const
{
	return circle::area()*height;
}
ostream& operator<<(ostream& output, const cylinder& cy)
{
	output << "center=[" << cy.x << "," << cy.y << "],r=" << cy.radius << ",h=" << cy.height << "\narea=" << cy.area() << ",volume="
		<< cy.volume() << endl;
	return output;
}
//main.cpp
#include<iostream>
using namespace std;
#include"point.h"
#include"circle.h"
#include"cylinder.h"



void main()
{
	point p(3.2,5.2);
	cout << p << endl;
	p.setpoint(4.5, 6.5);
	cout << "the new:"<<endl<<p << endl;
	circle c(1.2, 2.2, 3.2);
	cout << c << endl;
	c.setradius(3.3);
	cout << "the new:" << endl<< c << endl;
	cylinder cy(1.1, 2.1, 3.1, 4.1);
	cout << cy << endl;
	cy.setheight(4.2);
	cout << "the new" << cy << endl;
}


//测试虚析构函数
#include<iostream>
using namespace std;
class point
{
public:
	point(float x = 0, float y = 0){};
	virtual ~point(){ cout << "executing point destructor" << endl; }
protected:
	float x, y;
};

class circle :public point
{
public:
	circle(float x = 0, float y = 0, float r = 0) :point(x, y), radius(r){};
	~circle(){ cout << "executing circle destructor" << endl; }
private:
	float radius;
};


int main()
{
	point *p = new circle;
	delete p;
	cout << "ok" << endl;
	/*circle ci(3.2,5.2,3.3);
	point *p1 = &ci;
	*/
	return 0;
}


//12.4
#include<iostream>
#include<cmath>
using namespace std;
class shape
{
public:
	virtual void printArea()=0;

};
class triangle :public shape
{
public:
	triangle(float a, float b, float c) { x = a, y = b, z = c; };
	virtual void printArea();
protected:
	float x, y, z;
};
void triangle::printArea()
{
	cout<<"triangle area"<<((x*x + y*y + z*z) / 3)<<endl;
}
class circle :public shape
{
public:
	circle(float r){ radius = r; };
	virtual void printArea();
protected:
	float radius;
};
void circle::printArea()
{
	cout << "circle area" << 3.1415*radius*radius << endl;
}
void main()
{
	triangle t(1, 2, 3);
	circle c(1);
	shape *p;
	p = &t;
	p->printArea();
	p = &c;
	p->printArea();
}


//12.5
#include<iostream>
#include<cmath>
using namespace std;
class shape
{
public:
	virtual float printArea()=0;

};
class triangle :public shape
{
public:
	triangle(float a, float b, float c) { x = a, y = b, z = c; };
	virtual float printArea();
protected:
	float x, y, z;
};
float triangle::printArea()
{
	cout<<"triangle area"<<((x*x + y*y + z*z) / 3)<<endl;
	return((x*x + y*y + z*z) / 3);
}
class circle :public shape
{
public:
	circle(float r){ radius = r; };
	virtual float printArea();
protected:
	float radius;
};
float circle::printArea()
{
	cout << "circle area" << 3.1415*radius*radius << endl;
	return(3.1415*radius*radius);
}
void main()
{
	triangle t(1, 2, 3);
	circle c(1);
	shape *p[2];
	p[0] = &t;
	p[0]->printArea();
	p[1] = &c;
	p[1]->printArea();
	cout << (p[0]->printArea() + p[1]->printArea());

}


//const的使用
#include<iostream>
using namespace std;
class time
{
public:
	time(int h=0, int m=0, int s=0);
	int hour, minute, sec;
		void gettime();
};
time::time(int h, int m, int s) :hour(h), minute(m), sec(s){}
void time::gettime()
{
	cout << hour << ":" << minute << ":" << sec << endl;
}
void fun(time &p)
{
	p.hour = 18;
	cout << "the new:"<<p.hour << endl;
}

void main()
{
	time  t1(10, 13, 56);
	fun(t1);
	cout << t1.hour << endl;
}

//类模板运用
#include<iostream>
using namespace std;
template <typename T>
class compare
{
public:
	compare(T a, T b) : x(a), y(b){}
	T max()
	{
		return(x > y ? x : y);
	}
	T min()
	{
		return(x < y ? x : y);
	}
private:
	T x, y;
};
int main()
{
	compare<int>cmp1(2, 3);
	cout<<cmp1.max()<<"is the max one"<<endl;
	cout << cmp1.min() << "is the min one" << endl;
	compare<float>cmp2(3.2, 4.5);
	cout << cmp2.max() << "is the max one" << endl;
	cout << cmp2.min() << "is the min one" << endl;
	compare<char>cmp3('a', 'A');
	cout << cmp3.max() << "is the max one" << endl;
	cout << cmp3.min() << "is the min one" << endl;
	return 0;
}


//异常处理
#include<iostream>
using namespace std;
int main()
{
	void f1();
	try
	{
		f1();
	}
	catch (double)
	{
		cout << "ok0!" << endl;
	}
	cout << "end0" << endl;
	return 0;
}
void f1()
{
	void f2();
	try
	{
		f2();
	}
	catch (char)
	{
		cout << "ok1!";
	}
	cout << "end1" << endl;
}
void f2()
{
	void f3();
	try
	{
		f3();
	}
	catch (int)
	{
		cout << "ok2!" << endl;
	}
	cout << "end2" << endl;
}
void f3()
{
	double a = 0;
	try
	{
		throw a;
	}
	catch (double)
	{
		cout << "ok3!" << endl; throw;
	}
	cout << "end3" << endl;
}

//堆内存申请和释放
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
	int size;
	cout << "请输入数组的维数:" << endl;
	cin >> size;
	int *p = 0,*pm;
	p = new int[size];
	pm = p;
	for (int i = 0; i < size; i++)
	{
		p[i] = i * 10;
	}
	for (int i = 0; i < size; i++)
	{
		cout << "the nuber" <<setw(5)<< i << setw(10)<<"element:"<<setw(5);
		cout << *p++;
		cout << "\n";
	}
	p = pm;
	delete[] p;
	p = NULL;
	return
 0;
}


//改变申请的动态内存的大小
#include<iostream>
#include<iomanip>
#include<malloc.h>
using namespace std;
int main()
{
	int size = 4;
	int *p = 0,*pm;
	pm=p =new int[size];
	for (int i = 0; i < size; i++)
	{
		p[i] = i * 10;
	}
	for (int i = 0; i < size; i++)
	{
		cout << "the nuber" <<setw(5)<< i << setw(10)<<"element:"<<setw(5);
		cout << *p++;
		cout << "\n";
	}
	cout << endl;
	size = 8;
	p = pm;
	pm=p = (int *)realloc(p, sizeof(int)*size);
	for (int i = 4; i < size; i++)
	{
		p[i] = i * 10;
	}
	for (int i = 0; i < size; i++)
	{
		cout << "the nuber" << setw(5) << i << setw(10) << "element:" << setw(5);
		cout << *p++;
		cout << "\n";
	}
	
	p = pm;
	
	delete[] p;
	p = NULL;
	return 0;
}


//在新版编译器中（VS2013），alloca函数可能是被废止了，使用后会导致栈溢出（栈损坏）
#include<iostream>
#include<iomanip>
#include<malloc.h>
using namespace std;
int main()
{
	int Array[] = { 1, 2, 4, 5, 6 },size=5,m=0,n=0;
	for (int i = 0; i < size; i++)
	{
		cout << "the number" << setw(5) << i << setw(15) << "element is:" <<setw(5)<< Array[i] << endl;
	}
	cout << endl;
	int* p = Array;
	p = (int*)alloca(sizeof(int)* 6);
	for (int i = 0; i < size; i++)
	{
		cout << "the number" << setw(5) << i << setw(15) << "element is:" << setw(5) << Array[i] << endl;
	}
	cout << endl;

	m = Array[2];
	for (int i =3; i <(size); i++)
	{
		n = Array[i];
		Array[i]=m;
		m = n;
	}
	for (int i = 0; i < size; i++)
	{
		cout << "the number" << setw(5) << i << setw(15) << "element is:" << setw(5) << Array[i] << endl;
	}
	cout << endl;
	Array[5] = 6;
	size++;
	Array[2] = 3;
	for (int i = 0; i < size; i++)
	{
		cout << "the number" << setw(5) << i << setw(15) << "element is:" <<setw(5)<< Array[i] << endl;
	}
	return 0;
}


//sizeof的使用
#include<iostream>
#include<iomanip>
#include<malloc.h>
using namespace std;
int main()

//带参数宏的使用
// ch22_3.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>
using namespace std;
#define max(x,y,z) ((x)>(y)?((x)>(z)?(x):(z)):((y)>(z)?(y):(z)))
int main(int argc, char* argv[])
{
	
		float x;
		double y;
		float z;
	do
	{
		cin >> x;
		cin >> y;
		cin >> z;
		y = max(x, y, z);
		cout << y << endl;
	} while (x);
	return 0;
}
#undef max



//控制符的使用
#include<iostream>
#include<iomanip>
#include<string>
using namespace std;
int main()
{
	double a = 123.456, b = 3.13149, c = -3412.67;
	cout << setiosflags(ios::fixed) << setiosflags(ios::left) << setprecision(2);
	cout << setw(10) << a << setw(10) << a << endl;
	cout << setw(10) << b << setw(10) << b << endl;
	cout << setw(10) << c << setw(10) << c << endl;
	return 0;
}


//调试实验程序
#include<iostream>
#include<iomanip>
#include<string>
using namespace std;
int gcd(int, int);
int main()
{
	int x, y, z;
	cout << "input two integers:";
	cin >> x >> y;
	z = gcd(x, y);
	cout << "the greatest common divisor is" << z << endl;
	return 0;
}
int gcd(int a, int b)
{
	int t, c;
	cout << "start" << endl;
	if (a < b)
	{
		t = a, a = b, b = t;
	}
	c = a%b;
	while (c != 0)
	{
		a = b, b = c, c = a%b;
	}
	return b;
}


//计算周长，圆面积等，并输出
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
	float r = 1.5, h = 3;
	const double pi = 3.14159;
	double c, s1, s2, v1, v2;
	c = 2 * pi*r;
	s1 = pi*r*r;
	s2 = 4 * s1 / 3;
	v1 = 4 * s1*r;
	v2 = s1*h;
	cout << setiosflags(ios::fixed) << setprecision(4);
	cout << setw(6)<<"c:" << c << endl;
	cout << setw(6) << "s1:" << s1 << endl;
	cout << setw(6) << "s2:" << s2 << endl;
	cout << setw(6) << "v1:" << v1 << endl;
	cout << setw(6) << "v2:" << v2 << endl;
	

//输入输出字符及其ASCII值
#include<iostream>
#include<iomanip>
using namespace std;
int main()
{
	float r = 1.5, h = 3;
	const double pi = 3.14159;
	double c, s1, s2, v1, v2;
	c = 2 * pi*r;
	s1 = pi*r*r;
	s2 = 4 * s1 / 3;
	v1 = 4 * s1*r;
	v2 = s1*h;
	cout << setiosflags(ios::fixed) << setprecision(4);
	cout << setw(6)<<"c:" << c << endl;
	cout << setw(6) << "s1:" << s1 << endl;
	cout << setw(6) << "s2:" << s2 << endl;
	cout << setw(6) << "v1:" << v1 << endl;
	cout << setw(6) << "v2:" << v2 << endl;
	
}

//求阶乘
#include <iostream>
#include<string>
using namespace std;
long abc(int a);
int main()
{
	int a=1;
	while (1)
	{
		cout << "please input a positive integer" << endl;
		cin >> a;
		if (a>0)
		cout << abc(a) << endl;
		else break;
	}
	return 0;
}
long abc(int a)
{
	long b;
	if (a == 1)
		b = 1;
	else b =a*abc(a-1);
	return b;
}

//使用函数求最大值
#include <iostream>
#include<string>
using namespace std;
int max(int, int);
int main()
{
	int i, j;
	while (1)
	{
		cin >> i >> j;
		if (i != 0)
			cout << max(i, j) << endl;
		else break;
	}
	return 0;

}
int max(int a, int b)
{
	if (a > b)b = a;
	return b;
}

//sring变量的大小
#include <iostream>
#include<string>
using namespace std;

int main()
{
	string str,str1[3];
	str = "bei";
	cout << sizeof(str) << endl;
	cout << str.size() << endl;
	cout << str.length() << endl;
	cout << sizeof(string) << endl;
	cout << sizeof(str1) << endl;
	return 0;

}

//倒序输出数组元素
#include <iostream>
#include<string>
using namespace std;

int main()
{
	int iarr[] = { 1, 2, 3, 4, 5 },n=5;//"n" is the number of elements in the array
	void nn(int iarr[], int n);
	nn(iarr, n);
	for (int i = 0; i < n; i++)
	{
		cout << iarr[i] << "  ";
	}
	return 0;

}
void nn(int iarr[], int n)
{
	int t;
	t = iarr[0], iarr[0] = iarr[4], iarr[4] = t;
	t = iarr[1], iarr[1] = iarr[3], iarr[3] = t;
}


//输入字符串，并将以A开头的串输出
/*#include <iostream>
#include<string>
using namespace std;
int main()
{
	void swap(int*p1, int*p2);
	int *p1, *p2, a, b;
	p1 = &a, p2 = &b;
	while (1)
	{
		cin >> a >> b;
		if (a < 0)break;
		if (a < b)swap(p1, p2);
		cout << "max=" << a << "min=" << b << endl;
	}
	return 0;

}
void swap(int *p1, int*p2)
{
	int temp;
	temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}
*/
//输入字符串，并将以A开头的串输出
#include <iostream>
#include<string>
using namespace std;
int main()
{
	string str[50];
	int n = 4;
	void inputdata(string str[], int& n);
	inputdata(str, n);
	cout << endl;
	void outputdata(string str[], int& n);
	outputdata(str, n);
	return 0;

}
void inputdata(string str[], int& n)
{
	char str1[20];
	cout << "please input your string" << endl;
	for (int i = 0; i < n; i++)
	{
		cin.getline(str1, 20, '\n');
		str[i] = str1;
	}
}
void outputdata(string str[], int& n)
{
	for (int i = 0; i < n; i++)
	{
		if (str[i].at(0) == 'A')
			cout << str[i] << endl;

	}
}


//二级指针
#include <iostream>
#include<string>
using namespace std;
int main()
{
	char **p;
	char *name[] = { "basic", "for", "c++", "pas", "cobol" };
	p = name + 2;
	cout << *p << endl;
	cout << **p << endl;
	cout << p << endl;
	cout << name[2] << endl;
	cout << &name[2] << endl;
	int a[] = { 1, 2, 3 }, *p1=a;
	cout << a[1] << endl;
	cout << *(p1 + 1) << endl;
	cout << p1 << endl;
	char *p3 = "abc";
	cout << p3 << endl;
	return 0;
}

//P6.11
#include <iostream>
#include<string>
#include<iomanip>
using namespace std;
int main()
{
	int a[5][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 };
	void sort(int arr[][5]);
	sort(a);
	for (int i = 0; i < 5; i++)
	{
		for (int j = 0; j < 5; j++)
		{
			if (j<1)cout << endl;
			cout <<setw(5)<<a[i][j];
		}
	}
	cout << endl;
	return 0;
}
void change(const int&, int&, int&, int&,int&);
void sort(int arr[][5])
{
	int max, min1, min2, min3, min4;
	max = min1 = min2 = min3 = min4 = arr[2][2];
	for (int i = 0; i < 5;i++)
	{
		for (int j = 0; j < 5; j++)
		{
			if (arr[i][j]>max) max = arr[i][j];
			else if (arr[i][j] < min4)change(arr[i][j], min1, min2, min3, min4);//leave the new number into the four variable
		}
	}
	arr[0][0] = min1, arr[0][4] = min2, arr[4][0] = min3, arr[4][4] = min4, arr[2][2] = max;
}
void change(const int& a, int& m1, int& m2, int& m3, int& m4)
{
	int t;
	m4 = a;
	if (m4 < m3)
	{
		t = m4, m4 = m3, m3 = t;
		if (m3 < m2)
		{
			t = m3;
			m3 = m2;
			m2 = t;
			if (m2 < m1)
			{
				t = m2;
				m2 = m1;
				m1 = t;
			}
		}
	}

}

//定义结构体变量
#include <iostream>
#include<string>
#include<iomanip>
using namespace std;
struct person
{
	string name;
	int count;
};
int main()
{
	leader = { "li", 2121 };
	cout << leader.name << "  " << leader.count << endl;
	return 0;
}


//结构体的使用
#include <iostream>
#include<string>
#include<iomanip>
using namespace std;
struct student
{
	long num;
	string name;
	int score[3];
};
int main()
{	
	int n = 5;
	student str[5];
	cout << "please input the num,name,english score,chinese score and math score in order" << endl;
	for (int i = 0; i < 5; i++)
	{
		cin >> str[i].num >> str[i].name >> str[i].score[0] >> str[i].score[1] >> str[i].score[2];
	}
	void print(student st[],int& n);
	print(str,n);
	return 0;
}
void print(student str[], int& n)
{
	for (int i = 0; i < n;i++)
		cout << str[i].num << setw(15) << str[i].name <<setw(5) << str[i].score[0]<< setw(5) << str[i].score[1]<< setw(5) << str[i].score[2]<<endl;
}
//loadingks



//类的定义和使用
#include <iostream>
#include<string>
#include<iomanip>
using namespace std;
class Time
{
public:
	void set_time(void);
	void show_time(void);
private:
	int hour;
	int minute;
	int sec;

};
Time t;
int main()
{
	t.set_time();
	t.show_time();
}
void Time::set_time(void)
{
	cin >> hour >> minute >> sec;
}
void Time::show_time(void)
{
	cout << hour << ":" << minute << ":" << sec << endl;
}

//对象默认参数的使用
#include<iostream>
using namespace std;
class date
{
public:
	date(int=1, int=1, int=2015);
	/*date(int, int);
	date(int);
	date();
	*/
	void display();
private:
	int month;
	int day;
	int year;
};
date::date(int m, int d, int y) :month(m), day(d), year(y)
{}
/*date::date(int m, int d) : month(m), day(d){ year = 2015; }
date::date(int m) : month(m){ day = 1, year = 2015; }
date::date()
{
	year = 2015, month = 1, day = 1;
}
*/
void date::display()
{
	cout << month << "/" << day << "/" << year << endl;
}
int main()
{
	date d1(10, 13, 2015), d2(12, 30), d3(10), d4;
	d1.display();
	d2.display();
	d3.display();
	d4.display();
	return 0;
}

//习题9.5
#include<iostream>
#include<string>
using namespace std;
class student
{
public:
	student();
	void output();
	void set_value();
	int numoutput();
	int scoreoutput();
private:
	int num;
	int score;
};
student::student()
{
	num = 0;
	score = 0;
}
void student::output()
{
	cout << num << " : " << score << endl;
}
void student::set_value()
{
	cout << "please input the num and score" << endl;
	cin >> num >> score;
}
int student::numoutput()
{
	return num;
}
int student::scoreoutput()
{
	return score;
}
int main()
{
	int n = 5;
	student stu[5],*p=stu;
	for (int i = 0; i < 5; i++)
	{
		stu[i].set_value();
	}
	for (int i = 0; i < 5; i++)
	{	
		if (i%2==0)
		p->output();
		p++;
	}
	void max(student stu[],int& n);
	max(stu,n);
	
}
void max(student stu[],int& n)
{
	int num, score=0;
	for (int i = 0; i < n; i++)
	{
		if (stu[i].scoreoutput()>score)
			score = stu[i].scoreoutput(), num = stu[i].numoutput();
	}
	cout << num << " : " << score << endl;
}

//习题9.8
#include<iostream>
#include<string>
using namespace std;
class student
{
public:
	student(int n, float s) :num(n), score(s){};
	void change(int n, float s)const
	{
		num = n, score = s;
	}
	void display()const{ cout << num << " " << score << endl; }
private:
	mutable int num;
	mutable float score;
};
int main()
{
	student stud(101, 78.5);
	stud.display();
	stud.change(101, 89);
	stud.display();

	void fun(student&, int, float);
	fun(stud, 102, 90);
	return 0;
}
void fun(student& stud, int a, float b)
{
	stud.change(a, b);
	stud.display();
}

//习题9.9        静态数据成员使用前的先赋值
#include<iostream>
#include<string>
using namespace std;
class saler
{
public:
	static float average();
	static void display();
	saler(int num,int quantity,float price);
	static float discount;
	void countsum();
	void countn(); 
	static double sum;
	static int n;
private:
	
	int num;
	int quantity;
	float price;
};
void saler::countsum()
{
	sum = sum + quantity*price;
}
void saler::countn()
{
	n += quantity;
}
float saler::average()
{
	return(sum / n);
}
void saler::display()
{
	cout << sum << "    " << n << "     " << average() << endl;
}
saler::saler(int n, int q, float p) :num(n), quantity(q), price(p){}
int saler::n = 0;
double saler::sum = 0;
int main()
{

	saler s1(101, 5, 23.5), s2(102, 12, 24.56), s3(103, 100, 21.5);
	s1.countn(), s1.countsum(), s2.countn(), s2.countsum(), s3.countn(), s3.countsum();
	s1.display();
	return 0;
}


//转换构造函和类型转换函的使用
#include<iostream>
#include<string>
using namespace std;
class complex
{
public:
	complex(){ imag = 0, real = 0; }
	complex(double a, double b) :real(a), imag(b){}
	complex(double r){ real = r, imag = 0; }
	operator double(){ return real; }
private:
	friend complex operator+(complex&, complex&);
	friend ostream& operator<<(ostream&, complex&);
	
	double imag, real;
};
complex operator+(complex& a, complex& b)
{
	return complex(a.real + b.real, a.imag + b.imag);
}
ostream& operator<<(ostream& output, complex& b)
{
	output << b.real << "+" << b.imag << 'i' << endl;
	return output;
}
int main()
{
	complex c1(3.4, 5.6), c2(2.4, 7.8), c3;
	double d;
	c3 = c1 + c2;
	cout << c1 << c2 << c3 ;
	c3 = c1 + complex(3.9);
	//d = c1 + 3.9;用不了，书上的有误
	d = c1 + 3.9;
	cout << c3;
	cout << d;
}

//习题10.4
#include<iostream>
#include<string>
using namespace std;
class arr
{
public:
	arr(int = 0, int = 0, int = 0, int = 0, int = 0, int = 0 );
	void display();
	friend ostream& operator<<(ostream&, arr&);
	friend istream& operator>>(istream&, arr&);
	friend arr operator+(arr&, arr&);
private:
	int a[2][3];
};
arr::arr(int a1, int a2, int a3, int a4, int a5, int a6)
{
	a[0][0] = a1, a[0][1] = a2, a[0][2] = a3, a[1][0] = a4, a[1][1] = a5, a[1][2] = a6;
}
void arr::display()
{
	cout << a[0][0] << "  " << a[0][1] << "  " << a[0][2] << endl;
	cout << a[1][0] << "  " << a[1][1] << "  " << a[1][2] << endl;
}
ostream& operator<<(ostream& output, arr& d)
{
	output << d.a[0][0] << "  " << d.a[0][1] << "  " << d.a[0][2] << endl;
	output << d.a[1][0] << "  " << d.a[1][1] << "  " << d.a[1][2] << endl;
	return output;
}
istream& operator>>(istream& input, arr& d)
{
	input >> d.a[0][0] >>  d.a[0][1] >> d.a[0][2] ;
	input >> d.a[1][0] >>  d.a[1][1] >> d.a[1][2];
	return input;
}
arr operator+(arr&c, arr&d)
{
	arr e;
	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			e.a[i][j] = c.a[i][j] + d.a[i][j];
		}
	}
	return e;
}

int main()
{
	arr a(1,2,3,4,5,6), b(11,12,13,14,15,16),c,d;
	cout << a << endl << b << endl << c;
	c = a + b;
	cout << c;
	cin >> d;
	cout << endl;
	cout << d;

}

//习题11.2
#include<iostream>
#include<string>
using namespace std;
class student
{
public:
	void get_value()
	{
		cin >> num >> name >> sex;
	}
	void display()
	{
		cout << "num:" << num << endl;
		cout << "name:" << name << endl;
		cout << "sex:" << sex << endl;
	}
private:
	int num;
	string name;
	char sex;
};
class student_1:private student
{
public:
	void display_1()
	{
		display();
		cout << "age:" << age << endl;
		cout << "address:" << addr << endl;
	}
	void get_value1()
	{
		get_value();
		cin>> age >> addr;
	}
private:
	int age;
	string addr;
};
int main()
{
	student_1 s1;
	s1.get_value1();
	s1.display_1();
}

//习题11.7
#include<iostream>
#include<string>
using namespace std;
class A
{
public:
	A(){ a = 0, b = 0; }
	A(int i){ a = i, b = 0; }
	A(int i, int j){ a = i; b = j; }
	void display(){ cout << "a:" << a << "b:" << b; }
private:
	int a, b;
};
class B :public A
{
public:
	B(){ c = 0; }
	B(int i) :A(i){ c = 0; }
	B(int i, int j) :A(i, j){ c = 0; }
	B(int i, int j, int k) :A(i, j){ c = k; }
	void display1()
	{
		display();
		cout << "c:" << c << endl;
	}
private:
	int c;
};

int main()
{
	B b1;
	B b2(1);
	B b3(1, 3);
	B b4(1, 3, 5);
	b1.display1();
	b2.display1();
	b3.display1();
	b4.display1();
	return 0;
}

//构造和析构函数调用顺序
#include<iostream>
#include<string>
using namespace std;
class A
{
public:
	A(){ cout<<"con a"<<endl; }
	~A(){cout<<"des a"<<endl; }
};
class B :public A
{
public:
	B(){ cout << "con b" << endl; }
	~B(){ cout<<"des b"<<endl; }
};

int main()
{
	B b;
	return 0;
}

//习题11.9
#include<iostream>
#include<string>
using namespace std;
class teacher
{
public:
	teacher(string = "NON", int = 0, char = 'n', string = "NON", long = 000,string="NON");
	void display();
protected:
	string name;
	int age;
	char sex;
	string addr;
	long num;
	string title;
};
teacher::teacher(string na, int ag, char se, string ad, long nu, string ti) :name(na), age(ag), sex(se), addr(ad), num(nu), title(ti){}
void teacher::display()
{
	cout << "name:" << name << endl << "age:" << age << endl << "sex:" << sex << endl << "addr:" << addr << endl << "number:" << num << endl
		<< "title:" << title << endl;
}
class cadre
{
public:
	cadre(string = "NON", int = 0, char = 'n', string = "NON", long = 000, string = "NON");
protected:
	string name;
	int age;
	char sex;
	string addr;
	long num;
protected:
	string post;
};
cadre::cadre(string na, int ag, char se, string ad, long nu, string p) :name(na), age(ag), sex(se), addr(ad), num(nu), post(p){}
class teacher_cadre:public teacher,public cadre
{
public:
	teacher_cadre(string = "NON", int = 0, char = 'n', string = "NON", long = 000, string = "NON",string="NON",float=0);
	void show();
private:
	float wages;
};
teacher_cadre::teacher_cadre(string na, int ag, char se, string ad, long nu, string t, string p, float w) :teacher(na, ag, se, ad, nu, t),
	cadre(na, ag, se, ad, nu, p), wages(w){}
void teacher_cadre::show()
{
	display();
	cout << "post:" << post << endl << "wages:" << wages << endl;
	cout << "teacher::name  :" << teacher::name << endl << "cadre::name  :" << cadre::name << endl;
}
int main()
{
	teacher_cadre t("li", 19, 'f', "beijingroad", 8510333, "professor", "monitor", 6000);
	t.show();
}

//习题11.10
#include<iostream>
#include<string>
using namespace std;
class teacher
{
public:
	teacher(int = 0, string = "non", char = 'n');
	void display();
private:
	int num;
	string name;
	char sex;
};
teacher::teacher(int nu, string na, char se) :num(nu), name(na), sex(se){}
void teacher::display()
{
	cout << "num:" << num << endl << "name:" << name << endl << "sex:" << sex << endl;
}
class birthdate
{
public:
	birthdate(int = 0, int = 0, int = 0);
	void change1();
	void display1();
	private:
	int year;
	int month;
	int day;
};
void birthdate::display1()
{
	cout << year << '/' << month << '/' << day << endl;
}
void birthdate::change1()
{
	cout << "please input the date" << endl;
	cin >> year >> month >> day;
}
birthdate::birthdate(int y, int m, int d) :year(y), month(m), day(d){}
class professor :public teacher
{
public:
	professor(int = 0, string = "non", char = 'n', int = 0, int = 0, int d = 0);
	void change();
	void show();
private:
	birthdate birthday;
};
void professor::show()
{
	display();
	cout << "birthday:";
	birthday.display1();
}
professor::professor(int nu, string na, char se, int y, int m, int d) :teacher(nu, na, se), birthday(y, m, d){}
void professor::change()
{
	birthday.change1();
}
int  main()
{
	professor p(1001, "li", 'f', 1991, 9, 1);
	p.change();
	p.show();
}


//习题12.4,12.5
#include<iostream>
#include<string>
using namespace std;
#include"shape.h"
#include"rectangle.h"
#include"triangle.h"
int main()
{
	rectangle r(2,3);
	triangle t(5,7);
	shape *p=&r;
	p->printarea();
	p = &t;
	p->printarea();
	
	shape *p1[2] = { &r, &t };
	p1[0]->printarea();
	p1[1]->printarea();
	return 0;
}


//cerr的使用
#include<iostream>
#include<string>
#include<cmath>
using namespace std;
int main()
{
	float a, b, c, disc;
	cout << "please input a,b,c" << endl;
	cin >> a >> b >> c;
	if (a == 0)
		cerr << "a is 0,error!" << endl;
	else
	if ((disc = b*b - 4 * a*c) < 0)
		cerr << "disc<0" << endl;
	else
	{
		cout << 1 << endl;
		cout << 2 << endl;
	}
}


//对ASCII文件进行操作
#include<iostream>
#include<iomanip>
#include<fstream>
#include<string>
using namespace std;
int main()
{
	int a[10],b[10];
	ofstream outfile("f1.dat", ios::out);
	if (!outfile)
	{
		cout << "open error!" << endl;
		exit(1);
	}
	cout << "enter numbers" << endl;
	for (int i = 0; i < 10 ; i++)
	{
		cin >> a[i];
		outfile << a[i] << " ";
	}
	outfile.close();
	ifstream infile("f1.dat", ios::in);
	if (!infile)
	{
		cerr << "open error!" << endl;
		exit(1);
	}
	for (int i = 0; i < 10; i++)
	{
		infile >> b[i];
		cout << b[i] << " ";
	}
	cout << endl;
	infile.close();
	return 0;
}

//对二进制文件的操作
#include<iostream>
#include<iomanip>
#include<fstream>
#include<string>
using namespace std;
struct student
{
	char name[20];
	int num;
	int age;
	char sex;
};
int main()
{
	student stud[3] = { "li", 1001, 18, 'f', "fun", 1002, 19, 'm', "wang", 1004, 17, 'f' };
	ofstream outfile("stud.dat", ios::binary);
	if (!outfile)
	{
		cerr << "open error!" << endl;
		abort();
	}
	for (int i = 0; i < 3; i++)
		outfile.write((char*)&stud[i], sizeof(stud[i]));
	outfile.close();
	student stud1[3];
	int i;
	ifstream infile("stud.dat", ios::binary);
	if (!infile)
	{
		cerr << "open error" << endl;
		abort();
	}
	for (i = 0; i < 3; i++)
	{
		infile.read((char*)&stud1[i], sizeof(stud[i]));
	}
	infile.close();
	for (i = 0; i < 3; i++)
	{
		cout << i + 1 << endl;
		cout << stud1[i].name << endl;
		cout << stud1[i].num << endl;
		cout << stud1[i].age << endl;
		cout << stud1[i].sex << endl << endl;
	}
	return 0;
}



//cerr的使用，习题13.1
#include<iostream>
#include<iomanip>
#include<fstream>
#include<cmath>
#include<string>
using namespace std;
int main()
{
	float a, b, c;
	double area,s;
	do
	{
		cout << "please input three numbers" << endl;
		cin >> a >> b >> c;
		if ((a + b > c) && (a + c > b) && (b + c > a))
		{
			s = (a + b + c) / 2;
			area = sqrt(s*(s - a)*(s - b)*(s - c));
			cout << a << "   " << b << "   " << c << "   " << endl;
			cout << area << endl;
		}
		else
			cerr << "input wrong" << endl;
	} while (a);
	return 0;
}

//控制输出的使用，习题13.2,13.3
#include<iostream>
#include<iomanip>
#include<fstream>
#include<cmath>
#include<string>
using namespace std;
int main()
{
	double a[10] = {12.34,34.56,32.41,2.3,4.5,6.7,3.4,90.78,23.43,12.31};
	int i = 9,j=1;
	for (int i = 0; i < 10; i++)
	{
		cout << setprecision(3) << setiosflags(ios::fixed | ios::right) << setw(10) << a[i] << endl;
	}
	for (int k = 0; k < 8; k++)
	{
		cout << setw(i) << setfill(' ') << ' ' << setw(j) << setfill('B') << 'B' << endl;
		i -= 1, j += 2;
	}
	return 0;
}

//二进制文件输入输出的使用，有问题，习题13.5
#include<iostream>
#include<iomanip>
#include<fstream>
#include<cmath>
#include<string>
using namespace std;
int main()
{

	int a[20] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}, a1[20], a2[20], b;
	/*for (int i = 0; i < 10; i++)
	{
		cout << a[i] << setw(10) << a[i + 10] << endl;
	}
	for (int i = 0; i < 20; i++)
	{
		cin >> a[i];
	}
	*/
	fstream file1("f1.dat", ios::out | ios::in | ios::binary);
	file1.seekp(0, ios::beg);
	file1.write((char *)(&a[0]),10*sizeof(int));
	file1.seekg(0, ios::beg);
	file1.read((char*)(&a1[0]), 10 * sizeof(int));
	fstream file2("f2.dat", ios::out | ios::in | ios::binary);
	file2.seekp(0, ios::beg);
	file2.write((char *)(&a[10]), 10 * sizeof(int));
	file2.seekg(0, ios::beg);
	file2.read((char*)(&a2[0]), 10 * sizeof(int));
	for (int i = 0; i < 10; i++)
	{
		cout << a1[i] << setw(15)<<a2[i]<<endl;
	}
	cout << endl;
	
	file2.seekp(0, ios::beg);//
	file2.write((char*)(&a[0]), 20 * sizeof(int));

	file2.seekp(0, ios::end);//关联错误?????file2.seekp(-signed(1 * sizeof(int)), ios::beg);的用法要不得。现在的用法也有问题，无法把a1中的1,2,3……写进末尾
	file2.write((char*)(&a1[0]), 10 * sizeof(int));
	file2.seekg(0, ios::beg);
	file2.read((char*)(&a2[0]), 20 * sizeof(int));
	file1.close(), file2.close();
	for (int i = 0; i < 20; i++)
	{
		cout  << a2[i] << endl;
	}
	return 0;
}

//异常处理的使用，习题14.1
#include<iostream>
#include<iomanip>
#include<fstream>
#include<cmath>
#include<string>
using namespace std;
void  solve(float&,float&,float&);
int main()
{
	float a, b, c;
	do{
		cin >> a >> b >> c;
		try
		{
			solve(a,b,c);
		}
		catch (float n)
		{
			if (n == 0)
				cout << "its a wrong expression"<<endl;
			else
				cout << "there is no answer" << endl;
		}

	} while (a ！= 0 && b ！= 0);
		return 0;
}
void solve(float&a, float&b, float&c)
{
	if (a == 0)
		throw a;
	if ((b*b - 4 * a*c) < 0)
		throw a;
	double d1,d2;
	d1 = (-b + sqrt(b*b - 4 * a*c)) / (2 * a);
	d2 = (-b - sqrt(b*b - 4 * a*c)) / (2 * a);
	cout << "the result are as follows:" << endl << d1 << "    " << d2 << endl;
}


//练习1.10
#include<iostream>
using namespace std;
int main()
{
	cout << "ok" << endl;
	int a = 10;
	while (a >= 0)
	{
		cout << a<<endl;
		a--;
	}
	return 0;
}

//练习题1.13
#include<iostream>
using namespace std;
int main()
{
	cout << "ok" << endl;
	for (int a = 10; a >= 0;a--)
	{
		cout << a<<endl;
		
	}
	return 0;
}
//转义字符的使用
#include<iostream>
using namespace std;
int main()
{
	cout << "2M\n2\tM" << endl;
	return 0;
}

//引用的使用
#include<iostream>
using namespace std;
int main()
{
	int i = 0, &r1 = i;
	double d = 0, &r2 = d;
	cout << i << '\t' << r1 << '\t' << d << '\t' << r2 << endl;
	r2 = 3.14159;
	cout << i << '\t' << r1 << '\t' << d << '\t' << r2 << endl;
	r2 = r1;
	cout << i << '\t' << r1 << '\t' << d << '\t' << r2 << endl;
	i = 12;
	cout << i << '\t' << r1 << '\t' << d << '\t' << r2 << endl;
	r1 = 22;
	cout << i << '\t' << r1 << '\t' << d << '\t' << r2 << endl;
	return 0;
}

//string的使用
#include<iostream>
#include<iomanip>
#include<string>
using namespace std;
int main()
{
	string word;
	int i;
	/*while(getline(cin , word))
	{
		cout << word << endl;
	}
	while (cin >> word)
	{
		cout << word << endl;
	}
	*/
	string st1, st2;
	cin >> st1 >> st2;
	/*if (st1 == st2)
		cout << st1;
	else if (st1 > st2)
		cout << st1;
	else cout << st2;
	cout << endl << endl;
	if (st1.size() > st2.size())
		cout << st1;
	else cout << st2;
	cout << endl;
	*/
	cout << st1 + st2 << endl;
	cout << st1 + ' ' + st2 << endl;
	return 0;


}

//范围for的使用
#include<iostream>
#include<iomanip>
#include<string>
using namespace std;
int main()
{
	string str("abcsdadfa");
	cout << str << endl;
	for (auto& c : str)
		c = 'X';
	cout << str << endl;
	string s("a,b.c/d@e$r&g");
	cout << s << endl;
	for (char& c:s)
	if (ispunct(c))
		c = ' ';
	cout << s << endl;
	const string s1("keep out");
	for (auto &c : s1)
		cout << c << endl;
	return 0;
}


//vector的使用，有问题
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	vector<string> sv;
	string s;
	while (cin >> s)
		sv.push_back(s);
	for (auto i : sv)
		cout << i << endl;
	vector<int> iv;
	int i;
	while (cin >> i)//为嘛程序会略过后面这个循环呢？cin输入流的缘故？
		iv.push_back(i);
	for (auto i : iv)
		cout << i << " ";
	for (int j = 0; j < 10; j++)
	{
		cin >> i;
		iv.push_back(i);
	}
	for (auto i : iv)
		cout << i << " ";
	return 0;
}

//各种初始化的使用
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	vector<int> v1;
	vector<int> v2(10);
	vector<int> v3(10, 43);
	vector<int> v4{ 10 };
	vector<int> v5{ 10, 42 };
	vector<string> v6{ 10 };
	vector<string> v7{ 10, "hi" };
	cout<<v1.size()<<endl;
	if (v1.size()>0)
	for (auto i : v1)
		cout << i<<" ";
	cout << endl;
	cout << v2.size() << endl;
	if (v2.size()>0)
	for (auto i : v2)
		cout << i << " ";
	cout << endl;
	cout << v3.size() << endl;
	if (v3.size()>0)
	for (auto i : v3)
		cout << i << " ";
	cout << endl;
	cout << v4.size() << endl;
	if (v4.size()>0)
	for (auto i : v4)
		cout << i << " ";
	cout << endl;
	cout << v5.size() << endl;
	if (v5.size()>0)
	for (auto i : v5)
		cout << i << " ";
	cout << endl;
	cout << v6.size() << endl;
	if (v6.size()>0)
	for (auto i : v6)
		cout << i << " ";
	cout << endl;
	cout << v7.size() << endl;
	if (v7.size()>0)
	for (auto i : v7)
		cout << i << " ";
	cout << endl;
	return 0;
}

//练习3.17
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	vector<string> sv;
	string s;
	while (cin >> s)
		sv.push_back(s);
	for (auto& i : sv)
		cout << i << " ";
	cout << endl;
	for (auto& i : sv)
	{
		for (auto& j : i)
		{
			j = toupper(j);
		}
	}
	for (auto& i : sv)
		cout << i << " ";
	cout << endl;
	return 0;
}

//迭代器的使用
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	vector<int> iv{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
	for (auto i : iv)
		cout << i << " ";
	cout << endl;
	for (auto it = iv.begin(); it != iv.end(); it++)
		*it = (*it) * 2;
	for (auto i : iv)
		cout << i << " " ;
	cout << endl;
	auto it = iv.begin(), it1 = iv.end();
	cout << *it << "   " << *(it + 1) << endl;
	cout << (it<it1) << endl << (it>it1) << endl;
	return 0;
}


//练习3.25
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	vector<int> iv(10,0);
	auto it = iv.begin();
	unsigned i;
	while (cin>>i)
	if (i < 100)
		(*(it + i / 10))++;
	for (auto i : iv)
		cout << i << " ";
	cout << endl;
	return 0;
}
//练习3.24
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	vector<int> iv{ 1, 2,5 ,7,3, 4,6, 5, 6, 7,6, 8, 9, 0 };
	auto beg = iv.begin(), end = iv.end();
	unsigned j=0,k;
	for (int i = 1; i < iv.size(); i++)
		cout << (k=(*(beg + i) + *(beg + i - 1))) << "  ";
	cout << "end for" << endl;
	if (iv.size() % 2 == 1)
	{
		cout << "begin while1" << endl;
		while ((beg + j) != (end -j-1))
		{
			cout << (*(beg + j) + *(end - j-1)) << "  ";
			j++;
		}
		cout << *(beg + j) << endl;
		cout << "end while1" << endl;
	}
	else
	{
		cout << "begin while2" << endl;
		while (j < (iv.size() / 2))
		{
			cout << (*(beg + j) + *(end - j - 1)) << "  ";
			j++;
		}
		cout << endl;
		cout << "end while2" << endl;
	}
	cout << "end main" << endl;
	return 0;
}

//使用范围for语句来遍历数组
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	int ia[] = { 1, 2, 3, 4, 5 };
	for (int i:ia)
		cout << i << " ";
	cout << "end main" << endl;
	return 0;
}

//整型vector拷贝给整型数组
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	vector<int> iv = { 1, 2, 3, 4, 5 };
	int ia[5],j=0;
	for (int i : iv)
		*(ia + j) = i, j++;
	for (int i : ia)
		cout << i << " ";
	return 0;
}

//练习5.11
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	unsigned aCnt = 0, eCnt = 0, iCnt = 0,oCnt=0, uCnt = 0,sCnt=0,tCnt=0,nCnt=0;
	char ch,chm;
	while (cin.get(ch))
	{
		switch(ch)
		{
		case 'a':
		case 'A':
			++aCnt; break;
		case 'e':
		case 'E':
			++eCnt; break;
		case 'i':
		case 'I':
			++iCnt; break;
		case 'o':
		case 'O':
			++oCnt; break;
		case 'u':
		case 'U':
			++uCnt;
			break;
		case ' ':
			++sCnt;
			break;
		case '\t':
			++tCnt;
			break;
		case'\n':
			++nCnt;
			break;
		default:
			break;
		}
	}
	cout << "a:" << aCnt << endl
		<< "e:" << eCnt << endl
		<< "i:" << iCnt << endl
		<< "o:" << oCnt << endl
		<< "u:" << uCnt << endl
		<< "space:" << sCnt << endl
		<< "table:" << tCnt << endl
		<< "enter" << nCnt << endl;
	return 0;
}

//练习5。12
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	char ch1='\0', ch2;
	int ff = 0, fl = 0, fi = 0;
	while (cin >> ch2)
	{
		if (ch1 == 'f')
			switch (ch2)
		{
			case 'f':
				++ff;
				break;
			case'i':
				++fi;
				break;
			case'l':
				++fl;
				break;
			default:
				break;
		}
		ch1 = ch2;
	}
	cout << "ff;" << ff << endl
		<< "fi:" << fi << endl
		<< "fl:" << fl << endl;
	return 0;
}

//练习5.14
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	string s1,s2,s;
	int i = 0;
	vector<string> sv;
	vector<int> iv(3,1);
	if (cin >> s)
	{
		s1 = s;
		if (cin >> s)
		{
			if (s == s1)
			{
				sv.push_back(s);
				++iv[i];
			}
			s2 = s1, s1 = s;
			while (cin >> s)
			{
				if ((s == s1) && (s == s2))
				{
					++iv[i];
				}
				else if ((s == s1))
				{
					if (i > 1)
						break;
					sv.push_back(s);
					++iv[++i]; cout << i << endl;
				}
				s2 = s1, s1 = s;

			}
		}
	}
	int j = 0, max = 0;
	auto beg = iv.begin();
	for (i = 0; i < 3; i++)
	{
		if (max < *(beg + i))
			max = *(beg + i), j = i;
	}
	cout << sv[j] << "  :  " << *(beg + j) << endl;
	return 0;
}

//initializer_list类模板的使用
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int main()
{
	string expected("abc"), actual("efg");
	void error_msg(initializer_list<string> lst);
	error_msg({ "functionXa", expected, actual });
	cout << endl;
	error_msg({ "functionXb", "okay" });
	return 0;
}
void error_msg(initializer_list<string> lst)
{
	int k=0;
	for (auto beg = lst.begin(); beg != lst.end();++beg)
		cout << k++ <<":  "<< *beg << " " ;
//	for (auto i : lst)
//		cout << i << " ";
	cout << endl;
}

//练习6.33迭代函数输出向量vector
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int outvector(vector<int> iv, unsigned u)
{
	if (u == 1)
	{
		cout << iv[0]<<endl;
		return 0;
	}
	else
	{
		cout << iv[u - 1] << endl;
		return outvector(iv,u-1);
	}
};

int main()
{
	vector<int> iv{ 1, 2, 3, 4, 5 };
	cout<<outvector(iv, 4)<<endl;
	return 0;
}


//练习6.56
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
int f1(int a, int b)
{

	return (a + b);
}
int f2(int a, int b)
{

	return (a - b);
}
int f3(int a, int b)
{

	return (a * b);
}
int f4(int a, int b)
{

	return (a / b);
}
vector<int(*)(int, int)> fpv;

int main()
{
	vector<int(*)(int, int)> fv;
	int(*p1)(int a, int b);
	int(*p2)(int a, int b);
	int(*p3)(int a, int b);
	int(*p4)(int a, int b);
	p1 = f1, p2 = f2, p3 = f3, p4 = f4;
	fpv.push_back(p1), fpv.push_back(f2), fpv.push_back(f3), fpv.push_back(f4);
	cout << fpv[0](2, 4) << endl << fpv[1](2, 4) << endl << fpv[2](2, 4) << endl << fpv[3](2, 4)<<endl;
	return 0;
}

#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
class Date
{
public:
	Date(int i, int j, int k) :year(i), month(j), day(k){ cout << "1111111111111111" << endl; }
	Date() :Date(8, 8, 8){ cout << "2222222222222222222" << endl; }
	int year, month, day;
};
int main()
{
//	Date d1(2015,9,8);
	cout << endl;
	Date d2();
	return 0;
}

//委托构造函的使用
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
using namespace std;
class Date
{
public:
	Date(int i, int j, int k) :year(i), month(j), day(k){ cout << "1111111111111111" << endl; }
	Date() :Date(8, 8, 8){ cout << "2222222222222222222" << endl; }
	int year, month, day;
};
int main()
{
	Date d1(2015,9,8);
	Date d2;
	return 0;
}


//练习8.1
//练习8.1
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include"resource.h"
using namespace std;
istream& ioprint(istream& is)
{
	
	char c[80];
	//string s;
	while (!is.eof())
	{
		string s;
		is.getline(c, 80, '\n');//is.get(c);
		s = s + c;
		cout << "&&&&&&&& " << s << endl << "next:   "<<endl;
	}
	//cout << "########## " << s << endl << "next:   "<<endl;
	return is;
}
int main()
{
	ioprint(cin);
}

//命令行的使用
/开始——运行——CMD——pushd EXE文件路径——文件名.EXE 参数1 参数2 参数3
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include"resource.h"
using namespace std;

int main(int argc,char* argv[])
{
	string s;
	cout << argc << endl;
	s = s+argv[1] + argv[2];
	cout << s << endl;
}

//练习8.4
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include"resource.h"
#include<fstream>
using namespace std;

int main(int argc,char* argv[])
{
	char c[20],ct,*p=c;
	string s;
	int i = 0;
	vector<string> sv;
	ifstream input("file_from.txt");//打开文件，注意添加文件后缀.txt
	while (!input)
	{
		input.open("file_from.txt");
		cout << i++ << endl;
	}
	if (input)
	{
		while (input)
		{
		input.getline(c, 20, '\n');
		string s;
		s= s + c;//允许string和char型数组直接相加。very good
		cout << s << endl;
		sv.push_back(s);
		}
	}
	else cout << "error exist" << endl;
	for (string s : sv)
		cout << s << endl;
}
//练习8.5
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include"resource.h"
#include<fstream>
using namespace std;

int main(int argc,char* argv[])
{
	char c[20],ct,*p=c;
	int i = 0;
	vector<string> sv;
	ifstream input("file_from.txt");//打开文件，注意添加文件后缀.txt
	while (!input)
	{
		input.open("file_from.txt");
		cout << i++ << endl;
	}
	if (input)
	{
		while (input)
		{
			if (input.getline(c, 20, '\n'))//防止把文件结束符也放进s和sv中
			{
				string s;
				s = s + c;//允许string和char型数组直接相加。应该是隐式把char型数组转换为string串，very good
				cout << s << "********" << endl;
				sv.push_back(s);
			}
			else {
				cout << "error occured"<<endl;
				break;
			}
		}
	}
	else cout << "error exist" << endl;
	for (string s : sv)
		cout << s << endl;
}

//练习8.6
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
using namespace std;

int main(int argc,char* argv[])
{
	ifstream input("input.txt");
	Sales_item total;
	if (input >> total)
	{
		Sales_item trans;
		while (input >> trans)
		{
			if (total.isbn() == trans.isbn())
				total += trans;
			else
			{
				cout << total << endl;
				total = trans;
			}
		}
		cout << total << endl;
	}
	else cerr << "No data?!" << endl;
}


//练习8.7
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
using namespace std;

int main(int argc,char* argv[])
{
	ifstream input("input.txt");
	ofstream output("output.txt");
	Sales_item total;
	if (input >> total)
	{
		Sales_item trans;
		while (input >> trans)
		{
			if (total.isbn() == trans.isbn())
				total += trans;
			else
			{
				cout << total << endl;
				output << total << endl;
				total = trans;
			}
		}
		cout << total << endl;
		output << total << endl;
	}
	else cerr << "No data?!" << endl;
}
//练习8.10
//练习8.5
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include"resource.h"
#include<fstream>
using namespace std;

int main(int argc, char* argv[])
{
	char c[20], ct, *p = c;
	int i = 0;
	vector<string> sv;
	ifstream input("file_from.txt");//打开文件，注意添加文件后缀.txt
	while (!input)
	{
		input.open("file_from.txt");
		cout << i++ << endl;
	}
	while (input)
	{
		if (input.getline(c, 20, '\n'))//防止把文件结束符也放进s和sv中
		{
			string s;
			s = s + c;//允许string和char型数组直接相加。应该是隐式把char型数组转换为string串，very good
			cout << s << "********" << endl;
			sv.push_back(s);
		}
		else {
			cout << "error occured"<<endl;
			break;
		}
	} 
	for (string s : sv)
		cout << s << "********"<<endl;
	cout << endl;
	for (string s : sv)
	{
		string str; 
		istringstream iss(s);
		
		while (iss)
		{
			iss >> str;
			cout << "   "<<str << endl;
		}
		cout << "@@@@@@@@@@@@" << endl;
	}
}

练习
//练习8.5
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include"resource.h"
#include<fstream>
using namespace std;
vector<int> iv{ 1, 2, 4, 3, 5, 6, 7, 8, 9 };
vector<int>::iterator findNum(vector<int>::iterator& ite1, vector<int>::iterator& ite2, int a)
{
	while (ite1 != ite2)
	{
		if (*ite1 == a)
			return ite1;
		ite1++;
	}
	return ite2;
}
int main(int argc, char* argv[])
{
	auto ite1 = iv.begin(), ite2 = iv.end();
	int i=1;
	if (findNum(ite1, ite2, i)!=ite2)
	cout<<setw(4)<<"find the number "<<i<<endl;
	else cout << "there is not a such number" << endl;
}

练习9.11
//练习8.5
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include"resource.h"
#include<fstream>
using namespace std;

int main(int argc, char* argv[])
{
	list<string> autor = { "mmm", "kkkk" };
	vector<int> iv;
	vector<int> iv1(iv);
	vector<int> iv2{ 1, 2, 3, 4, 5 };
	auto iter1 = iv2.begin(), iter2 = iv2.end();
	vector<int> iv3(++iter1, iter2);
	vector<int> iv4(5);
	vector<int> iv5(5, 8);
	for (auto k : iv)
		cout << k << "    ";
	cout << endl;
	for (auto k : iv1)
		cout << k << "    ";
	cout << endl;
	for (auto k : iv2)
		cout << k << "    ";
	cout << endl;
	for (auto k : iv3)
		cout << k << "    ";
	cout << endl;
	for (auto k : iv4)
		cout << k << "    "; cout << endl;
	for (auto k : iv5)
		cout << k << "    "; cout << endl;


	for (int i = 0; i < 6; i++)
	{
		string s("iv");
		s += char(48+i);
		
		cout << s << endl;
	}
}


练习9.13
//练习8.5
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include"resource.h"
#include<fstream>
using namespace std;

int main(int argc, char* argv[])
{
	list<int> lst{ 1, 2, 3, 4, 5, 6 };
	auto iter1 = lst.begin(), iter2 = lst.end();
	vector<double> dv(++iter1, iter2);
	vector<int> iv{ 1, 2, 4, 5, 6, 6, 7, 7 };
	auto iter3 = iv.begin(), iter4 = iv.end();
	vector<double> dv1(iter3, iter4);
	for (auto k : dv)
		cout << k << "   ";
	cout << endl;
	for (auto k : dv1)
		cout << k << "   ";
}

练习9.14
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include"resource.h"
#include<fstream>
using namespace std;

int main(int argc, char* argv[])
{
	list<char *> cl{ "aaa", "bbb", "ccc", "ddd" };
	auto iter1 = cl.begin(), iter2 = cl.end();
	vector<string> sv;
	sv.assign(iter1, iter2);
	for (auto k : sv)
		cout << k << endl;
}

练习9.18
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include"resource.h"
#include<fstream>
using namespace std;

int main(int argc, char* argv[])
{
	string str;
	deque<string> de;
	while (cin >> str)
		de.push_back(str);
	auto ite = de.begin();
	while (ite != de.end())

		cout << *ite++ << "    ";	
			
}


练习9.20
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include"resource.h"
#include<fstream>
using namespace std;

int main(int argc, char* argv[])
{
	list<int> lst{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11, 12, 13, 14, 15 };
	auto iter = lst.begin();
	deque<int> deq1, deq2;
	auto iter1 = deq1.begin(), iter2 = deq2.begin();
	while (iter != lst.end()){
		if ((*iter % 2) == 1)
			iter1 = deq1.insert(iter1, *iter);
		else iter2 = deq2.insert(iter2, *iter);		
		iter++;
	}
	for (auto k : deq1)
		cout << k << "    ";
	cout << endl;
	for (auto k : deq2)
		cout << k << "    ";
	cout << endl;
}

练习9.27，forward_list还是不好用，连个迭代器加减法都不支持
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include<fstream>
using namespace std;

int main(int argc, char* argv[])
{
	forward_list<int> flst{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11, 12, 13, 14, 15 };
	auto prev = flst.before_begin(),cur=flst.begin();
	while (cur != flst.end())
	{
		if (*cur % 2)
			cur = flst.erase_after(prev);
		else {
			prev = cur;
			cur++;
		}
	}
	for (auto k : flst)
		cout << k << "   ";
	cout << endl;
}


练习9.40

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include<fstream>
using namespace std;
int main(int argc, char* argv[])
{
	vector<int> vi;
	int i;
	vi.reserve(3000);
	while (cin >> i)
		vi.push_back(i);
	vi.resize(vi.size() + vi.size() / 2);
	cout << vi.size() << "   "kkk");
	cout << s << endl;
	
}


练习9.43

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include<fstream>
using namespace std;
void replaces(string& s, string oldval, string newval)
{
	unsigned k=0;
	while (k != s.size())
	{
		if (s.substr(k, oldval.size()) == oldval)
		{
			s.replace(k, oldval.size(), newval);
		//	s.erase(k, oldval.size());
		//	s.insert(k, newval);
			k += newval.size();

		}
		k++;
	}
}
int main(int argc, char* argv[])
{
	string s("abcdddddabcdddddabcdddd");
	replaces(s, "abc", "kkk");
	cout << s << endl;
	
}


练习9.43

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include<fstream>
using namespace std;
void replaces(string& s, string oldval, string newval)
{
	auto cur = s.begin(),ite=s.end();
	int i = 0;
	auto begin = newval.begin(), end = newval.end();
	while (cur != s.end())
	{
		ite = cur+oldval.size();
		if (string(cur, cur + oldval.size()) == oldval)
		{
			cur = s.erase(cur, cur + oldval.size());
			cur=s.insert(cur, begin,end);
			cur += newval.size();
		}
		else  ++cur;
		if (ite == s.end())
			break;
	}
}

int main(int argc, char* argv[])
{
	string s("abcdddddabcdddddabcdddd");
	replaces(s, "abc", "kkk");
	cout << s << endl;
	
}

练习9.47

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include<fstream>
using namespace std;

int main(int argc, char* argv[])
{
	string s("ab2c3d7R4E6"), numbers("1234567890");
	for (unsigned pos = 0; pos < s.size(); pos++)
	{
		pos=s.find_first_of(numbers, pos);
		cout << s[pos] << "   ";
	}
	cout << "ok"<<endl;
	for (unsigned pos = 0; pos < s.size(); pos++)
	{
		pos = s.find_first_not_of(numbers, pos);
		if (pos == -1)
			break;
		cout << s[pos] << "   ";
	}
	return 0;
}
练习9.50

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include<fstream>
using namespace std;

int main(int argc, char* argv[])
{
	vector<string> vs{ "11.2", "22.2", "33.2", "44.2" };
	double sum=0;
	for (auto k : vs)
		sum += stod(k);
	cout << sum << endl;
	return 0;
}

练习9.51

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include<fstream>
using namespace std;
class date
{
public:
	date(string s);
	void getdate()
	{
		cout << year << "-" << month << "-" << day;
	}
private:
	unsigned year, month, day;
};
date::date(string s)
{
	unsigned pos1, pos2,pos3;
	
	string str;
	if ((pos1 = s.find_first_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")) != string::npos)
	{
		int k;
		pos2 = s.find_first_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", pos1 + 1);
		pos3 = s.find_first_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", pos1 + 2);
		k = s[pos1] + s[pos2] + s[pos3];
		switch(k)
		{
			case 'j' + 'a' + 'n':
				str = "01"; break;
			case  'f' + 'e' + 'b':
				str = "02"; break;
			case  'm' + 'a' + 'r':
				str = "03"; break;
			case  'a' + 'p' + 'r':
				str = "04"; break;
			case  'm' + 'a' + 'y':
				str = "05"; break;
			case  'j' + 'u' + 'n':
				str = "06"; break;
			case  'j' + 'u' + 'l':
				str = "07"; break;
			case  'a' + 'u' + 'g':
				str = "08"; break;
			case  's' + 'e' + 'p':
				str = "09"; break;
			case  'o' + 'c' + 't':
				str = "10"; break;
			case  'n' + 'o' + 'v':
				str = "11"; break;
			case  'd' + 'e' + 'c':
				str = "12"; break;
		}
		month = stoi(str);
		pos1 = s.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
		pos2 = s.find_first_not_of("1234567890",pos1+1);
		str = s.substr(pos1 + 1, pos2 - pos1 - 1);
		day = stoi(str);
		str = s.substr(pos2+1);
		year = stoi(str);
	}
	else
	{
		pos1 = s.find_first_of("1234567890");
		pos2 = s.find_first_not_of("1234567890");
		str = s.substr(pos1, pos2 - pos1);
		month = stoi(str);
		pos3 = s.find_first_not_of("1234567890", pos2 + 1);
		str = s.substr(pos2 + 1, pos3 - pos2 - 1);
		day = stoi(str);
		str = s.substr(pos3+1);
		year = stoi(str);
	}
}
int main(int argc, char* argv[])
{
	date da("january 1,1990"), da1("10/19/1993"), da2("feb 6 1997");
	da.getdate();
	cout << endl;
	da1.getdate();
	cout << endl;
	da2.getdate();
	cout << endl;
	return 0;
}


算法的使用

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include<fstream>
#include<numeric>
#include<algorithm>
using namespace std;
int main()
{
	vector<double> vi{ 1, 2, 0, 3, 4, 5, 0, 6, 7, 8.9, 0, 9 };
	cout << count(vi.begin(), vi.end(), 0) << endl;
	cout << accumulate(vi.begin(), vi.end(), 0.0) << endl;
	vector<const char*> vc{ "abc", "def", "ghi" };
	vector<const char*> vc2{ "abc", "dewf", "ghi", "jkl" };
	cout << equal(vc.begin(), vc.end(), vc2.begin()) << endl;
	cout << endl;
	fill_n(vi.begin(), 2, 9);
	for (auto k : vi)
		cout << k << "  ";
	replace(vi.begin(), vi.end(), 0, 333);
	cout << endl;
	for (auto& k : vi)
		cout << k << "  ";
}


练习10.12

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>
using namespace std;
bool compareIsbn1(Sales_item s1, Sales_item s2)
{
	return(s1.isbn() < s2.isbn());
}
int main()
{
	vector<Sales_item> vs{ string("kkk"), string("eee"), string("bbb"), string("iii"), string("aaa") };
	for (const auto&k : vs)
		cout << k << endl;
	sort(vs.begin(), vs.end(), compareIsbn1);
	for (const auto&k : vs)
		cout << k << endl;
}

练习10.13

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>
using namespace std;
bool strsize(string& s)
{
	return(s.size() > 4);
}
int main()
{
	vector<string> vs{ "1234", "12345", "ab", "abcdef" };
	auto ite=partition(vs.begin(), vs.end(), strsize);
	auto begin = vs.begin();
	while (begin != ite)
		cout << *begin++ << endl;
}

练习10.14，10.15，10.17

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>
using namespace std;

int main()
{
	auto sum = [](int a, int b){return a + b; };
	cout << sum(1, 2) << endl;
	int c = 9;
	auto sum2 = [c](int a){return a + c; };
	cout << sum2(3) << endl;
	vector<Sales_item> vs{ string("kkk"), string("eee"), string("bbb"), string("iii"), string("aaa") };
	sort(vs.begin(), vs.end(), [](Sales_item a, Sales_item b){return a.isbn() < b.isbn(); });
	for (const auto& k : vs)
		cout << k << endl;
}

练习10.20

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>
using namespace std;

int main()
{
	vector<string> vs{ "1234", "1234567", "ab", "abcdefgh" };
	int cnt=5;
	cout<<count_if(vs.begin(), vs.end(), [cnt](const string& s){return s.size() > cnt; });
	cout << endl;
}



练习10.21

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>
using namespace std;

int main()
{
	int a = 10;
	auto k = [&a]()->bool {if (a) { while (a)a--; return 0; } else return 1; };
	cout << k() << endl;
	cout << k() << endl;
}

练习10.22

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>
#include<functional>
using namespace std;
using namespace placeholders;
int countNum(const string& s, int a)
{
	return s.size() > a ? 1: 0;
}
int main()
{
	vector<string> vs{ "1234", "1234567", "ab", "abcdefgh","aslfalsfk" };
	int cnt=5;
	auto bind1 = bind(countNum, _1, cnt);
	cout<<count_if(vs.begin(), vs.e		s=s+k;
	cout << s << endl;
}



练习10.30

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>
#include<functional>
using namespace std;
using namespace placeholders;

int main()
{
	istream_iterator<int> iter1(cin), end1;
	vector<int> vi;
	copy(iter1, end1, back_inserter(vi));
	sort(vi.begin(), vi.end());
	for (auto k : vi)
		cout << k << "   ";
	cout << endl;
	ostream_iterator<int> iter2(cout,"   ");
	copy(vi.cbegin(), vi.cend(), iter2);
	cout << endl;

	
}

练习10.32

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>
#include<functional>
using namespace std;
using namespace placeholders;

int main()
{
	vector<Sales_item> v_sales;
	istream_iterator<Sales_item> iter1(cin), end;
	copy(iter1, end, back_inserter(v_sales));

	sort(v_sales.begin(), v_sales.end(), [](Sales_item& a, Sales_item& b){return a.isbn() < b.isbn(); });

	auto begin = v_sales.begin(),end2=v_sales.begin();

	while (begin != v_sales.end())
	{
		end2 = find_if(begin, v_sales.end(), [begin](Sales_item& a){return a.isbn() != begin->isbn(); });
		cout << accumulate(begin, end2, Sales_item(begin->isbn())) << endl;
		begin = end2;
	}
}

练习11.8

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>
#include<functional>
#include<map>
using namespace std;
using namespace placeholders;

int main()
{
	map<string, vector<string>> mapF = { { "li", {} }, { "wang", { } } };
	string s, s1,s2;
	while (getline(cin, s))
	{
		istringstream record(s);
		record >> s1;
		while (record >> s2)
			mapF[s1].push_back(s2);
	}
	for (auto k : mapF)
	{
		cout << k.first << ":   ";
		for (auto i : k.second)
			cout << i << "
   ";
		cout << endl;
	}

	
}

练习11.12

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>
#include<functional>
#include<map>
#include<utility>
using namespace std;
using namespace placeholders;

int main()
{
	vector<pair<string, int>> vp;
	string s;
	int i;
	while (cin >> s)
	{
		cin >> i;
		vp.push_back({ s, i });
	}
	for (auto k : vp)
	{
		cout << k.first << ":   " << k.second << endl;
	}
}


练习11.31

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>
#include<functional>
#include<map>
#include<set>
#include<utility>
using namespace std;
using namespace placeholders;

int main()
{
	multimap<string, string> mm{ { "aaa", "111" }, { "aaa", "222" }, {"bbb","333"} };
	string s;
	auto it1 = mm.find(s);
	while (it1 != mm.end())
	{
		mm.erase(it1);
		it1 = mm.find(s);
	}
}

练习11.32

#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<utility>//pair定义所在头文件
using namespace std;
using namespace placeholders;

int main()
{
	multimap<string, string> mm{ { "kkk", "444" },{ "aaa", "111" }, { "aaa", "222" }, { "bbb", "333" } };
	auto it2 = mm.begin();
	pair<string,string> p1 = *it2;
	cout << p1.first << ":  ";
	for (const auto& k : mm)
	{
		if (k.first == p1.first)
			cout << k.second << "   ";
		else
		{
			p1 = k;
			cout << endl << k.first << ":  " << k.second << "   ";
		}
	}
}

练习11.38
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
using namespace std;
using namespace placeholders;

int main()
{
	unordered_map<string, size_t> word_count;
	string word;
	while (cin >> word)
		++word_count[word];
	for (const auto&k : word_count)
		cout << k.first << ":   " << k.second << endl;
	return 0;
}


练习12.6
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
using namespace std;
using namespace placeholders;
vector<int>* build(void)
{
	vector<int>* vip = new vector<int>;
	return vip;
}
vector<int>* readNum(vector<int>* p)
{
	int i;
	while (cin >> i)
		p->push_back(i);
	return p;
}
void printNum(vector<int>* p)
{
	for (auto k : *p)
		cout << k << "   ";
	cout << endl;
}
int main()
{
	printNum(readNum(build()));
}


练习12.7
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
using namespace std;
using namespace placeholders;
shared_ptr<vector<int>> build(void)
{
	return shared_ptr<vector<int>>(new vector<int>);
}
shared_ptr<vector<int>> readNum(shared_ptr<vector<int>> p)
{
	int i;
	while (cin >> i)
		p->push_back(i);
	return p;
}
void printNum(shared_ptr<vector<int>> p)
{
	for (auto k : *p)
		cout << k << "   ";
	cout << endl;
}
int main()
{
	printNum(readNum(build()));
}

练习12.17
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
using namespace std;
using namespace placeholders;


int main()
{
	unique_ptr<int> u1(new int(45));
	unique_ptr<int> u2;
	int ix = 1024, *pi = &ix, *pi2 = new int(2048);
	using Upi = unique_ptr<int>;
	Upi p1(pi);
	Upi p2(pi2);
	Upi p3(&ix);
	Upi p4(p2.get());
	cout << *p2 << endl;
	cout << *p4 << endl;
	return 0;
}

练习12.22
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>

using namespace std;
using namespace placeholders;

class constStrBlobPtr {
public:
	constStrBlobPtr() : curr(0) {}
	constStrBlobPtr(const StrBlob& a, size_t sz = 0) : wptr(a.data), curr(sz) {}
	bool operator!=(const constStrBlobPtr& p) { return p.curr != curr; }
	string& deref() const
	{
		auto p = check(curr, "dereference past end");
		return (*p)[curr];
	}
	constStrBlobPtr& incr()
	{
		check(curr, "increment past end of StrBlobPtr");
		++curr;
		return *this;
	}

private:
	std::shared_ptr<vector<string>> check(size_t i, const string& msg) const
	{
		auto ret = wptr.lock();
		if (!ret) throw std::runtime_error("unbound StrBlobPtr");
		if (i >= ret->size()) throw std::out_of_range(msg);
		return ret;
	}
	std::weak_ptr<vector<string>> wptr;
	size_t curr;
};
int main()
{
	ifstream inputF("file_from.txt");
	StrBlob SS;
	string str;
	while (getline(inputF, str))
	{
		SS.push_back(str);
	}
	const StrBlob S(SS);
	constStrBlobPtr SP(S);
	while (1)
	{
		try{
			cout << SP.deref() << endl;
			SP.incr();
		}
		catch (runtime_error e)
		{
			cout << e.what() << endl;
			cout << "object not exist" << endl;
			break;
		}
		catch (out_of_range o)
		{
			cout << "ok" << endl;
			break;
		}
	}
	return 0;
}


练习12.23
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>

using namespace std;
using namespace placeholders;

int main()
{
	char a[] = "abcd", b[] = "efghijkl";
	char *p = new char[sizeof(a)+sizeof(b)-1];
	unsigned k=0,j=0;
	while (a[k] != '\0')
		p[k] = a[k],k++;
	while (b[j] != '\0')
		p[k + j] = b[j], j++;
	p[k + j] = '\0';
	cout << p << endl;
	delete []p;
	return 0;
}

练习12.28
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>

using namespace std;
using namespace placeholders;
void query(const string  s, const vector<string>& file, const map<string, shared_ptr<set<vector<string>::size_type>>> wm);
int main()
{
	using lines_no = vector<string>::size_type;
	ifstream input("file_from.txt");
	vector<string> file;
	string s;
	map<string, shared_ptr<set<lines_no>>> wm;
	while (getline(input, s))
	{
		file.push_back(s);
		int n = file.size() - 1;
		string word;
		istringstream line(s);
		while (line >> word)
		{
			auto &lines = wm[word];
			if (!lines)
				lines.reset(new set<lines_no>);
			lines->insert(n);
		}
	}
	while (1)
	{
		cout << "please input your word" << endl;
		if (cin >> s)
			query(s, file, wm);
		else
		{
			cout << "input wrong" << endl;
			break;
		}
			cout << "go on" << endl;
	}

}

void query(const string  s,const vector<string>& file,const map<string, shared_ptr<set<vector<string>::size_type>>> wm)
{
	auto loc = wm.find(s);
	if (loc == wm.end())
		cout << "not find";
	else
	{

		cout << s << "occours" << (loc->second)->size() << "times" << endl;
		for (auto num : *(loc->second))
		{
			cout << "\nlines" << num + 1 << ":" << file[ num ] << endl;
		}
	}		
}


练习13.39，答案程序有点问题
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>

using namespace std;
using namespace placeholders;
class StrVec {
public:
	StrVec() : elements(nullptr), first_free(nullptr), cap(nullptr) {}
	StrVec(const StrVec&);
	StrVec& operator=(const StrVec&);
	~StrVec();

	void push_back(const std::string&);
	size_t size() const { return first_free - elements; }
	size_t capacity() const { return cap - elements; }
	std::string* begin() const { return elements; }
	std::string* end() const { return first_free; }

	void reserve(size_t new_cap);
	void resize(size_t count);
	void resize(size_t count, const std::string&);

private:
	std::pair<std::string*, std::string*> alloc_n_copy(const std::string*,
		const std::string*);
	void free();
	void chk_n_alloc()
	{
		if (size() == capacity()) reallocate();
	}
	void reallocate();
	void alloc_n_move(size_t new_cap);

private:
	std::string* elements;
	std::string* first_free;
	std::string* cap;
	std::allocator<std::string> alloc;
};
void StrVec::push_back(const std::string& s)
{
	chk_n_alloc();
	alloc.construct(first_free++, s);
}

std::pair<std::string*, std::string*> StrVec::alloc_n_copy(const std::string* b,
	const std::string* e)
{
	auto data = alloc.allocate(e - b);
	return{ data, std::uninitialized_copy(b, e, data) };
}

void StrVec::free()
{
	if (elements) {
		for (auto p = first_free; p != elements;) alloc.destroy(--p);
		alloc.deallocate(elements, cap - elements);
	}
}

StrVec::StrVec(const StrVec& rhs)
{
	auto newdata = alloc_n_copy(rhs.begin(), rhs.end());
	elements = newdata.first;
	first_free = cap = newdata.second;
}

StrVec::~StrVec()
{
	free();
}

StrVec& StrVec::operator=(const StrVec& rhs)
{
	auto data = alloc_n_copy(rhs.begin(), rhs.end());
	free();
	elements = data.first;
	first_free = cap = data.second;
	return *this;
}

void StrVec::alloc_n_move(size_t new_cap)
{
	auto newdata = alloc.allocate(new_cap);
	auto dest = newdata;
	auto elem = elements;
	for (size_t i = 0; i != size(); ++i)
		alloc.construct(dest++, std::move(*elem++));
	free();
	elements = newdata;
	first_free = dest;
	cap = elements + new_cap;
}

void StrVec::reallocate()
{
	auto newcapacity = size() ? 2 * size() : 1;
	alloc_n_move(newcapacity);
}

void StrVec::reserve(size_t new_cap)
{
	alloc_n_move(new_cap);
}
void StrVec::resize(size_t count)
{
	if (count < size())
	{
		string* tem = elements + count;
		string* t=first_free;
		while (--t != tem)
		{
			alloc.destroy(t);
		}
		alloc.destroy(--t);
		first_free = tem;
	}
	else if (count > size() && count <= capacity())
	{
		uninitialized_fill(first_free, (elements + count), "");
		first_free = elements + count;
	}
	else if (count > capacity())
	{
		uninitialized_fill(first_free, cap, "");
		first_free = cap;
		alloc_n_move(count);
	}
}


int main()
{
	StrVec sv;
	sv.push_back("111");
	cout << sv.size()<<endl<<sv.capacity()<<endl;
//	sv.reserve(10);
//	sv.resize(10);
	cout << sv.size() << endl << sv.capacity() << endl;
	return 0;
}

练习13.48
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
using namespace std;
class String
{
public:
	String(){ elements = first_free = cap = nullptr; }
	String(char *);
	String(const String&);
	String(String &&s);
	String& operator=(String&&);
	String& operator=(const String&);
	size_t size()const{ return first_free - elements; }
	char *begin()const{ return elements; }
	char* end()const{ return (first_free-1); }
	void free();
	void push_back(char );

private:
	char* elements;
	char* first_free;
	char* cap;
};
String::String(char*p)
{
//	cout << "in structor with array" << endl;
	const int i = sizeof(p);
	elements = new char[i-1];
	first_free = cap = elements +i- 1;
	char* p1 = elements;
	char* cp = p;
	for (int j = 0; j < (i-1);j++)
	{
		*p1++ = *cp++;
	}
}
String::String(const String& s)
{
	cout << "in structor with left value" << endl;
	const int  i = s.size();
	elements = new char[i];
	first_free = cap = elements + i;
	char* p1 = elements;
	char* p2 = s.elements;
	while (p2 != s.first_free)
	{
		*p1++ = *p2++;
	}
}
String::String(String &&s)
{
	cout << "in structor of right value" << endl;
	elements = s.elements;
	first_free = cap = s.first_free;
	s.elements = s.first_free = s.cap = nullptr;
}

String& String:: operator=(String&&s)
{
	elements = s.elements;
	first_free = cap = s.first_free;
	s.elements = s.first_free = s.cap = nullptr;
	return *this;
}
void String::free()
{
	delete[]elements;
	elements = first_free = cap = nullptr;
}
void String::push_back(char c)
{
	const int j = size();
	auto newdata = new char[j + 1];
	char* p1 = elements;
	char* p2 = newdata;
	while (p1 != first_free)
	{
		*p2++ = *p1++;

	}
	*p2 = c;
	free();
	elements = newdata;
	cap = elements + j + 1;
	first_free = elements + j + 1;
}


int main()
{
	String s("abc");
	cout << *s.begin() << "   " << *s.end()<<endl;
	char d = 'd';
	s.push_back(d);
	cout << *s.begin() << "   " << *s.end() << endl;
	vector<String> VS{ "abc", "def", "ghi" };
}

练习14.26#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
using namespace std;
class String
{

public:
	String(){ elements = first_free = cap = nullptr; }
	String(char *);
	String(const String&);
	String(String &&s);
	String& operator=(String&&);
	String& operator=(const String&);
	size_t size()const{ return first_free - elements; }
	char *begin()const{ return elements; }
	char* end()const{ return (first_free - 1); }
	void free();
	void push_back(char);
	char & operator[](size_t n);

	friend bool operator==(const String&, const String&);
	friend bool operator!=(const String&, const String&);
	friend bool operator<(const String&, const String&);


private:
	char* elements;
	char* first_free;
	char* cap;
};
char & String::operator[](size_t n)
{
	if (n >= size())		
	{
		throw runtime_error("out of range");
			return *(begin());
	}
	return *(begin() + n);
	
}
bool operator==(const String& s1, const String& s2)
{
	return *s1.begin() == *s2.begin();
}
bool operator!=(const String& s1, const String s2)
{
	return !(s1 == s2);
}
bool operator<(const String& s1, const String& s2)
{
	return (*s1.begin() )< (*s2.begin());
}

String::String(char*p)
{
	//	cout << "in structor with array" << endl;
	const int i = sizeof(p);
	elements = new char[i - 1];
	first_free = cap = elements + i - 1;
	char* p1 = elements;
	char* cp = p;
	for (int j = 0; j < (i - 1); j++)
	{
		*p1++ = *cp++;
	}
}
String::String(const String& s)
{
	cout << "in structor with left value" << endl;
	const int  i = s.size();
	elements = new char[i];
	first_free = cap = elements + i;
	char* p1 = elements;
	char* p2 = s.elements;
	while (p2 != s.first_free)
	{
		*p1++ = *p2++;
	}
}
String::String(String &&s)
{
	cout << "in structor of right value" << endl;
	elements = s.elements;
	first_free = cap = s.first_free;
	s.elements = s.first_free = s.cap = nullptr;
}

String& String:: operator=(String&&s)
{
	elements = s.elements;
	first_free = cap = s.first_free;
	s.elements = s.first_free = s.cap = nullptr;
	return *this;
}
void String::free()
{
	delete[]elements;
	elements = first_free = cap = nullptr;
}
void String::push_back(char c)
{
	const int j = size();
	auto newdata = new char[j + 1];
	char* p1 = elements;
	char* p2 = newdata;
	while (p1 != first_free)
	{
		*p2++ = *p1++;

	}
	*p2 = c;
	free();
	elements = newdata;
	cap = elements + j + 1;
	first_free = elements + j + 1;
}


int main()
{
	String s("abc");
		cout << *s.begin() << "   " << *s.end() << endl;
	char d = 'd';
	s.push_back(d);
	cout << *s.begin() << "   " << *s.end() << endl;
	vector<String> VS{ "abc", "def", "ghi" };
	String s1("akd");
	cout << (s1 == s )<< endl;
	cout << (s1 < s) << endl;
}

练习14.35
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
using namespace std;

class IfThen
{
public:
	int operator()(int a, int b, int c){ return a ? b : c; }
};
class PringString
{
public:
	string operator()(istream &is)
	{
		string s;
		if (getline(is, s))
			return s;
		else return string();
	}
};
int main()
{
	IfThen i1;
	cout << i1(3, 2, 1) << endl;
	PringString p1;
	cout << p1(cin) << endl;
}

练习14.36
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
using namespace std;

class IfThen
{
public:
	int operator()(int a, int b, int c){ return a ? b : c; }
};
class PringString
{
public:
	string operator()(istream &is)
	{

		if (getline(is, s))
			return s;
		else
		{
			s = string();
			return s;
		}
	}
	const string& get(){ return s; }
private:
	string s;

};
int main()
{
	IfThen i1;
	cout << i1(3, 2, 1) << endl;
	PringString p1;
	cout << p1(cin) << endl;
	vector<string> vs;
	while (1)
	{
		vs.push_back(p1(cin));
		if (p1.get()== string())
			break;
	}
	cout << endl;
	for (auto k : vs)
		cout << k << endl;
}
练习14.44
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
using namespace std;
int add(int i, int j){ return i + j; }
auto mod = [](int i, int j){return i%j; };
struct divide{ int operator()(int i, int j){ return i / j; } };
int main()
{
	map<string, function<int(int,int)>> binops=
	{
		{ "+",add},
		{ "-", minus<int>() },
		{ "*", [](int i, int j){return i*j; } },
		{ "/", divide() },
		{ "%",mod }
	};
	int i, j;
	char c;
	string s;
	cout << "please input your operation" << endl;
	while (cin >> i)
	{
		if (cin >> c)
		{
			s = c;
			if (cin >> j)
				cout << binops[s](i, j) << endl;
			else break;
		}
		else break;
	}

}

关于继承说明符和访问说明符
class Base
{
public:
	void pub_mem();
	void memfcn(Base &b){ b = *this; }
protected:
	int prot_mem;
private:
	char priv_mem;
};

struct Pub_Derv :public Base
{
	int f(){ return prot_mem; }
	void memfcn(Base &b){ b = *this; }
};
struct Priv_Derv :private Base
{
	int f1();
	void memfcn(Base &b){ b = *this; }
};
struct Prot_Derv:protected Base
{

};
struct Derived_from_Public :public Pub_Derv
{
	int use_base(){ return prot_mem; }
	void memfcn(Base &b){ b = *this; }
};
struct Derived_from_Private :public Priv_Derv
{

};
struct Derived_from_Protected :public Prot_Derv
{

};
Pub_Derv d1,dk;
Priv_Derv d2;
Prot_Derv d3;
Derived_from_Public dd1;
Derived_from_Private dd2;
Derived_from_Protected dd3;
int main()
{	
	Base *p = &d1;
	
}


练习16.4
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>

using namespace std;

template<typename T,typename F>
typename T fde(T& it1,T& it2,const F&v)
{
	T it = it1;
	while (it != it2&&*it!=v)
			else ++it;
	return it;
}
int main()
{
	
	vector<int> vi{ 1, 2, 3, 4, 5, 6, 7, 8 };
	auto& it = fde(vi.begin(), vi.end(), 8);
	cout << *it << endl;
	list<string> lst{ "abc", "ok", "good", "some" };
	auto& it1 = fde(lst.begin(), lst.end(), "ok");
	cout << (it1 == lst.end() ? "not found" : *it1) << endl;
	it1++;
	cout << (it1 == lst.end() ? "not found" : *it1) << endl;

	it1++;
	cout << (it1 == lst.end() ? "not found" : *it1) << endl;

	it1++;
	cout << (it1 == lst.end() ? "not found" : *it1) << endl;
	auto it2 = fde(lst.begin(), lst.end(), "sss");
	cout << (it1 == lst.end() ? "not found" : *it1) << endl;
}

练习16.5
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>

using namespace std;


template<typename T,unsigned N>
void print(T(&arr)[N])
{
	for (auto elem : arr)
		cout << elem << endl;
}
int main()
{
	int arri[] = { 1, 2, 3, 4, 5, 6 };
	string arrs[] = { "abc", "edf", "ok", "good" };
	print(arri);
	print(arrs);
}


练习16.6,16.7
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>

using namespace std;


template<typename T,unsigned N>
void print(T(&arr)[N])
{
	for (auto elem : arr)
		cout << elem << endl;
}
template<typename T,unsigned N>
T* beginn(T(&arr)[N])
{
	return arr;
}
template<typename T, unsigned N>
T* endd(T(&arr)[N])
{
	return (arr+N);
}
template<typename T, unsigned N>
unsigned sizearr(T(&arr)[N])
{
	return N;
}


int main()
{

	int arri[] = { 1, 2, 3, 4, 5, 6 };
	string arrs[] = { "abc", "edf", "ok", "good" };
	print(arri);
	print(arrs);
	cout << sizeof(arri) << endl;
	cout << sizeof(arrs) << endl;
	auto beg = beginn(arri);
	auto end = endd(arri);
	while (beg != end)
		cout << *beg++ << endl;
	cout << sizearr(arri) << endl;
	cout << sizearr(arrs) << endl;
}

练习16.6
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
#include"ex13_39.h"

using namespace std;


template<typename T>
class Vec {
public:
	Vec() : elements(nullptr), first_free(nullptr), cap(nullptr) {}
	Vec(const Vec&);
	Vec& operator=(const Vec&);
	~Vec();
	void push_back(const T&);
	size_t size() const { return first_free - elements; }
	size_t capacity() const { return cap - elements; }
	T* begin() const { return elements; }
	T* end() const { return first_free; }

	void reserve(size_t new_cap);
	void resize(size_t count);
	void resize(size_t count, const T&);

private:
	std::pair<T*, T*> alloc_n_copy(const T*,
		const T*);
	void free();
	void chk_n_alloc()
	{
		if (size() == capacity()) reallocate();
	}
	void reallocate();
	void alloc_n_move(size_t new_cap);

private:
	T* elements;
	T* first_free;
	T* cap;
	std::allocator<T> alloc;
};


template<typename T>
void Vec<T>::push_back(const T& s)
{
	chk_n_alloc();
	alloc.construct(first_free++, s);
}

template<typename T>
std::pair<T*, T*> Vec<T>::alloc_n_copy(const T* b,
	const T* e)
{
	auto data = alloc.allocate(e - b);
	return{ data, std::uninitialized_copy(b, e, data) };
}

template<typename T>
void Vec<T>::free()
{
	if (elements) {
		for (auto p = first_free; p != elements;) alloc.destroy(--p);
		alloc.deallocate(elements, cap - elements);
	}
}

template<typename T>
Vec<T>::Vec(const Vec<T>& rhs)
{
	auto newdata = alloc_n_copy(rhs.begin(), rhs.end());
	elements = newdata.first;
	first_free = cap = newdata.second;
}

template<typename T>
Vec<T>::~Vec()
{
	free();
}
template<typename T>
Vec<T>& Vec<T>::operator=(const Vec<T>& rhs)
{
	auto data = alloc_n_copy(rhs.begin(), rhs.end());
	free();
	elements = data.first;
	first_free = cap = data.second;
	return *this;
}

template<typename T>
void Vec<T>::alloc_n_move(size_t new_cap)
{
	auto newdata = alloc.allocate(new_cap);
	auto dest = newdata;
	auto elem = elements;
	for (size_t i = 0; i != size(); ++i)
		alloc.construct(dest++, std::move(*elem++));
	free();
	elements = newdata;
	first_free = dest;
	cap = elements + new_cap;
}

template<typename T>
void Vec<T>::reallocate()
{
	auto newcapacity = size() ? 2 * size() : 1;
	alloc_n_move(newcapacity);
}

template<typename T>
void Vec<T>::reserve(size_t new_cap)
{
	if (new_cap <= capacity()) return;
	alloc_n_move(new_cap);
}

template<typename T>
void Vec<T>::resize(size_t count)
{
	resize(count);
}

template<typename T>
void Vec<T>::resize(size_t count, const T& s)
{
	if (count > size()) {
		if (count > capacity()) reserve(count * 2);
		for (size_t i = size(); i != count; ++i)
			alloc.construct(first_free++, s);
	}
	else if (count < size()) {
		while (first_free != elements + count) alloc.destroy(--first_free);
	}
}



int main()
{
	Vec<int> vi, vi1;
	vi.push_back(1);
	vi.push_back(2);
	vi.push_back(3);
	vi.push_back(4);
	auto it = vi.begin();
	while (it != vi.end())
		cout << *it++ << endl;
	//	vi1 = vi;                      //这个赋值存在问题，uninitialized_copy使用出问题了,是作者的代码的问题，不改成模板也一样出问题
	//	for (auto &elem : vi1)
	//		cout << elem << endl;
	Vec<string> vs, vs1;
	vs.push_back("ok");
	vs.push_back("good");
	vs.push_back("beauty");
	vs.push_back("very");
	auto it1 = vs.begin();
	while (it1 != vs.end())
		cout << *it1++ << endl;
}
int main()
{
	StrVec vs, vs1;
	vs.push_back("ok");
	vs.push_back("good");
	vs.push_back("beauty");
	vs.push_back("very");
	auto it1 = vs.begin();
	while (it1 != vs.end())
		cout << *it1++ << endl;
	vs1 = vs;
	for (auto elem : vs1)
		cout << elem << endl;
}



练习16.9
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
#include"ex13_39.h"

using namespace std;
template<typename T>
void print(T& v)
{
	typename T::size_type s=0;
	auto it = v.begin();
	while (s++ < v.size())
	{
		cout <<*( it++ )<< endl;//lst.begin()+1不被支持，为何？
	}
}
int main()
{
	vector<int> vi{ 1, 2, 3, 4, 5, 6, 7 };
	list<char> lst{ 'a', 's', 'd', '9' };
	print(vi);
	cout << endl;
	print(lst);
}


练习16.19
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
#include"ex13_39.h"

using namespace std;
template<typename T>
void print(T& v)
{
	typename T::size_type s=0;
	auto it = v.begin();
	while (it!=v.end())
	{
		cout <<*( it++)<< endl;//lst.begin()+1不被支持，为何？
	}
}
class String
{
public:
	String(string s): S(s)
	{};
	string getstr(){ return S; }
	string S;
};
int main()
{
	vector<int> vi{ 1, 2, 3, 4, 5, 6, 7 };
	list<char> lst{ 'a', 's', 'd', '9' };
	print(vi);
	cout << endl;
	print(lst);
	vector<String> vs;
	vs.push_back(String("aaa"));
	cout <<(vs.begin()->getstr()) << endl;
}


练习7.13,参考答案是用的一个模板类，不错
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
#include"ex13_39.h"
#include<bitset>
using namespace std;
bitset<10>  bit("1100011000");//
void setbit(size_t t, bool b)
{
	bit.set(t, b);//bit[t] = b;
}
string s("1100011001");
void answer(string s, bitset<10> bit)
{
	size_t t=0;
	int count=0;
	bitset<10> bit1(s);
	while (t < 10)
	{
		if(bit1[t] == bit[t]) count++ ;
		t++;
	}
	cout << count << " answers are not correct" << endl;
}
int main()
{
	answer(s, bit);
}
练习17.15
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"Sales_item.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
#include"ex13_39.h"
#include<bitset>
#include<regex>
using namespace std;

int main()
{
	
	regex r("[[:alpha:]]*[^c]ei[[:alpha:]]*");
	smatch results;
	string s;
	while (cin >> s&&s!="q")
	{
		if (regex_search(s, results, r))
			cout << not ok:" << s << endl;
		else cout << "ok:" << s << endl;
	}
}

练习18.10
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
#include"ex13_39.h"
#include<bitset>
#include<regex>
#include<exception>
#include"Sales_item.h"
using namespace std;

int main()
{
	try
	{
		Sales_item s1("good"), s2("man");
		cout << s1.isbn() << endl;
		cout << s2.isbn() << endl;
		cin >> s1;
		cin >> s2;
		cout << s1 << endl;
		cout << s2 << endl;	
		s1 += s2;
		cout << s1 << endl;
		
	}
	catch (isbn_mismatch e)
	{
		cout << e.what() << endl;
		cout << "isbn:" << e.left << "  not equal to" << "  isbn:" << e.right << endl;
	}
	cout << "program finished" << endl;	
}

练习19.18
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
#include"ex13_39.h"
#include<bitset>
#include<regex>
#include<exception>
#include"Sales_item.h"
using std::cin;
using std::cout;
using std::endl;
using std::count_if;
using std::mem_fn;
size_t count(vector<string>& vs)
{
	return count_if(vs.begin(), vs.end(), mem_fn(&string::empty));
}
int main()
{
	vector<string> vs{ "", "", "abc", "eee", "", "kkk" };
	cout << count(vs) << endl;
}

单链表的操作（面向过程实现）
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
#include"ex13_39.h"
#include<bitset>
#include<regex>
#include<exception>
#include"Sales_item.h"
using std::cin;
using std::cout;
using std::ends;
using std::endl;
using std::count_if;
using std::mem_fn;
using ElemType = int;
typedef struct LNode//单链表存储结构
{
	ElemType data;
	LNode *next;
}LNode,*LinkList;

LinkList InitList_L(LinkList L)//链表初始化
{
	L = new(LNode);
	if (!L) return 0;
	L->next = NULL;
	return L;
}
int ListInsert_L(LinkList L, int i, ElemType e)//单链表插入
{
	LNode*p, *s;
	int j;
	p = L;
	j = 0;
	while (p&&j < i - 1){ p = p->next; j++; }
	if (!p || j>i - 1) return 0;
	s = new(LNode);
	s->data = e;
	s->next = p->next; p->next = s;
	return 1;
}
int ListDelete_L(LinkList L, int i, ElemType *e)//单链表的删除
{
	LNode *p, *q;
	int j;
	p = L; j = 0;
	while (p->next&&j < i - 1)
	{
		p = p->next; ++j;
	}
	if (!(p->next) || j>i - 1)return 0;
	q = p->next;
	*e = q->data;
	p->next = q->next;
	delete q;
	return 1;
}
LinkList CreateList_L(int n)//单链表的建立
{
	LNode *L, *p, *q;
	int i; 
	L = new(LNode);
	L->next = NULL;
	q = L;
	for (i = 1; i <= n; ++i)
	{
		p = new LNode;
		cout << "please input the number " << i << " element";
		cin >> p->data;
		p->next = NULL;
		q->next = p;
		q = p;
	}
	return L;
}
int LocateElem_L(LinkList L, ElemType e)//单链表的查找
{
	LNode *p;
	int i;
	p = L->next; i = 1;
	while (p&&p->data != e)
	{
		p = p->next; i++;
	}
	if (p == NULL) return 0;
	else return i;
}
void PrintLinkList(LinkList L)//单链表的打印
{
	LNode *p;
	p = L->next;
	cout << endl << "单链表各元素值为：";
	while (p)
	{
		cout << p->data <<ends<<ends ;
		p = p->next;
	}
}
int main()
{
	LinkList L;
	int n, i, e, status;
	cout << "please input the length of the list" << endl;
	cin >> n;
	L = CreateList_L(n);
	PrintLinkList(L);
	status = ListInsert_L(L, 4, 27);
	if (status)
	{
		cout << endl << endl << "进行插入后";
		PrintLinkList(L);
	}
	else
	{
		cout << endl << endl << "插入失败"; return 1;
	}
	status = ListDelete_L(L, 5, &e);
	if (status)
	{
		cout << endl << endl << "被删除元素的值为:" << e << endl << endl << "进行删除操作后";
		PrintLinkList(L);
	}
	else{
		cout << "删除失败"; return 0;
	}
	cout << endl << endl << "请输入要查找的值：e=";
	cin >> e;
	i = LocateElem_L(L, e);
	if (i) cout << "该元素在表中的位序为：" << i;
	else cout << "该元素在表中不存在";
	return 0;
}

单链表的实现（面向对象）
#include<sstream>
#include<iostream>
#include<iomanip>
#include<string>
#include<vector>
#include<list>
#include<deque>
#include<forward_list>
#include"resource.h"
#include"ex12_19.h"
#include<fstream>
#include<numeric>
#include<algorithm>//算法定义所在头文件
#include<functional>//标准库函数对象以及function类所在头文件
#include<map>
#include<set>
#include<unordered_map>
#include<utility>//pair定义所在头文件
#include<memory>
#include"ex13_39.h"
#include<bitset>
#include<regex>
#include<exception>
#include"Sales_item.h"
using std::cin;
using std::cout;
using std::ends;
using std::endl;
using std::count_if;
using std::mem_fn;
using std::shared_ptr;
using std::bad_alloc;

class List
{
public:
	using ElemType = int;
	typedef struct LNode//单链表存储结构
	{
		ElemType data;
		LNode *next;
	}LNode,*LinkList;
	//using LinkList = shared_ptr<LNode>;//using smart point will be a better choice;
	List();
	int ListInsert_L(int i, ElemType e);
	int ListDelete_L( int i, ElemType *e);
	int LocateElem_L( ElemType e);
	void CreateList_L(int n);
	void PrintLinkList();
private:
	LinkList L;
};
List::List()//链表初始化,构造
{
	L = new(LNode);
	if (!L) throw bad_alloc();
	L->next = NULL;	
}

int List::ListInsert_L(int i, ElemType e)//单链表插入
{
	LNode*p, *s;
	int j;
	p = L;
	j = 0;
	while (p&&j < i - 1){ p = p->next; j++; }
	if (!p || j>i - 1) return 0;
	s = new(LNode);
	s->data = e;
	s->next = p->next; p->next = s;
	return 1;
}
int List::ListDelete_L(int i, ElemType *e)//单链表的删除
{
	LNode *p, *q;
	int j;
	p = L; j = 0;
	while (p->next&&j < i - 1)
	{
		p = p->next; ++j;
	}
	if (!(p->next) || j>i - 1)return 0;
	q = p->next;
	*e = q->data;
	p->next = q->next;
	delete q;
	return 1;
}
void List::CreateList_L(int n)//单链表的建立
{
	LNode *p, *q;//in fact ,we should identify if the List is empty or not,if not ,wo should delete all its node at the second.
	int i; 
	q = L;
	for (i = 1; i <= n; ++i)
	{
		p = new LNode;
		cout << "please input the number " << i << " element";
		cin >> p->data;
		p->next = NULL;
		q->next = p;
		q = p;
	}
}

int List::LocateElem_L(ElemType e)//单链表的查找
{
	LNode *p;
	int i;
	p = L->next; i = 1;
	while (p&&p->data != e)
	{
		p = p->next; i++;
	}
	if (p == NULL) return 0;
	else return i;
}
void List::PrintLinkList()//单链表的打印
{
	LNode *p;
	p = L->next;
	cout << endl << "单链表各元素值为：";
	while (p)
	{
		cout << p->data <<ends<<ends ;
		p = p->next;
	}
}

int main()
{
	List L;
	int n, i, e, status;
	cout << "please input the length of the list" << endl;
	cin >> n;
	L.CreateList_L(n);
	L.PrintLinkList();
	status = L.ListInsert_L(4, 27);
	if (status)
	{
		cout << endl << endl << "进行插入后";
		L.PrintLinkList();
	}
	else
	{
		cout << endl << endl << "插入失败"; return 1;
	}
	status = L.ListDelete_L(5, &e);
	if (status)
	{
		cout << endl << endl << "被删除元素的值为:" << e << endl << endl << "进行删除操作后";
		L.PrintLinkList();
	}
	else{
		cout << "删除失败"; return 1;
	}
	cout << endl << endl << "请输入要查找的值：e=";
	cin >> e;
	i = L.LocateElem_L(e);
	if (i) cout << "该元素在表中的位序为：" << i;
	else cout << "该元素在表中不存在";
	return 0;
}
